library(stringr)
library(openxlsx)
library(stringi)

#' @title
#' diff_xlsx
#'
#' @description
#' Allow to see the difference between two datasets and output it into an xlsx file. If the dimensions of the new datasets are bigger than the old one, only the matching cells will be compared, if the dimensions of the new one are lower than the old one, there will be an error.  
#' @param file_ is the file where the data is
#' @param sht is the sheet where the data is
#' @param v_old_begin is a vector containing the coordinates (row, column) where the data to be compared starts
#' @param v_old_end is the same but for its end
#' @param v_new_begin is the coordinates where the comparator data starts
#' @param v_new_end is the same but for its end
#' If the dimensions of the new datasets are bigger than the old one, only the matching cells will be compared, if the dimensions of the new one are lower than the old one, there will be an error.  
#' @param df2 is optional, if the comparator dataset is directly a dataframe
#' @param overwrite allow to overwrite differences is (set to T by default)
#' @param color_ is the color the differences will be outputed
#' @param pattern is the pattern that will be added to the differences if overwritten is set to TRUE 
#' @param output is the name of the outputed xlsx (can be set to NA if no output)
#' @param new_val if overwrite is TRUE, then the differences will be overwritten by the comparator data
#' @param pattern_only will cover differences by pattern if overwritten is set to TRUE 
#' @export

diff_xlsx <- function(file_, sht, v_old_begin, v_old_end, 
                      v_new_begin, v_new_end, df2=NA, overwrite=T, 
                      color_="red", pattern="", output="out.xlsx", new_val=T,
                      pattern_only=T){
  
  rd <- read.xlsx(file_, sheet=sht, col_names=NA)
  
  data_ <- data.frame(rd)
  
  df <- data_[v_old_begin[1]:v_old_end[1], v_old_begin[2]:v_old_end[2]]
  
  if (is.na(df2) == F){
    
    df2 <- df2[v_new_begin[1]:v_new_end[1], v_new_begin[2]:v_new_end[2]]
    
  }else{
    
    df2 <- data_[v_new_begin[1]:v_new_end[1], v_new_begin[2]:v_new_end[2]]
    
  }
  
  nb_diff = 0
  
  c_l <- c()
  
  c_c <- c()
  
  for (I in 1:ncol(df)){
    
    for (i in 1:nrow(df)){
      
      if (df[i, I] != df2[i, I]){
        
        nb_diff = nb_diff + 1
        
        c_l <- append(c_l, i)
        
        c_c <- append(c_c, I)
        
        if (overwrite == T){
          
          if (new_val == T){
            
            data_[i + v_old_begin[1] - 1, I + v_old_begin[2] - 1] <- df2[i, I]
            
          }else{
            
            if (pattern_only == F){
              
              data_[i + v_old_begin[1] - 1, I + v_old_begin[2] - 1] <- pattern
              
            }else{
              
              data_[i + v_old_begin[1] - 1, I + v_old_begin[2] - 1] <- paste0(data_[i + v_old_begin[1] - 1, I + v_old_begin[2] - 1], pattern)
              
            }
            
          }
          
        }
        
      }
      
    }
    
  }
  
  if (is.na(output) == F){
    
    f <- output
    
  }else{
    
    f <- file_
    
  }
  
  if (overwrite == T){
    
    write.xlsx(data_, output, rowNames=FALSE, colNames=FALSE)
    
  }
  
  wb <- loadWorkbook(f)
  
  diff_style <- createStyle(fontColour = "red",
                            fontSize = 11,
                            fontName="Trebuchet MS",
                            halign = "center",
                            valign = "center",
  )
  
  addStyle(wb,
           "Sheet 1",
           diff_style,
           c_l,
           c_c,
  )
  
  saveWorkbook(wb, f, overwrite=T)
  
  return(nb_diff)
  
}

#' insert_df
#'
#' Allow to insert dataframe into another dataframe according to coordinates (row, column) from the dataframe that will be inserted
#' @param df_in is the dataframe that will be inserted 
#' @param df_ins is the dataset to be inserted
#' @param ins_loc is a vector containg two parameters (row, column) of the begining for the insertion
#' @export

insert_df <- function(df_in, df_ins, ins_loc){

  ins_loc <- ins_loc - 1
  
  df_pre1 <- df_in[0:ins_loc[1], 1:ncol(df_in)] 
  
  if ((ins_loc[1] + nrow(df_ins)) > nrow(df_in)){
    
    df_pre2 <- df_in[(ins_loc[1]+1):nrow(df_in), 1:ncol(df_in)]
    
    df_pre3 <- df_in[0:0, 1:ncol(df_in)]
    
    row_end <- nrow(df_pre2)
    
  }else{
    
    df_pre2 <- df_in[(ins_loc[1]+1):(ins_loc[1]+nrow(df_ins)), 1:ncol(df_in)]
    
    df_pre3 <- df_in[(ins_loc[1] + nrow(df_ins) + 1):nrow(df_in), 1:ncol(df_in)]
    
    row_end <- nrow(df_ins)
    
  }
  
  t = 1
  
  for (i in 1:ncol(df_ins)){
    
    df_pre2[, (ins_loc[2]+i)] <- df_ins[1:row_end, t] 
    
    t = t + 1
    
  }
  
  rtnl <- rbind(df_pre1, df_pre2, df_pre3)
  
  return(rtnl)
  
}

#' pattern_generator
#'
#' Allow to create patterns which have a part that is varying randomly each time.
#' @param base_ is the pattern that will be kept
#' @param from_ is the vector from which the elements of the random part will be generated
#' @param hmn is how many of varying pattern from the same base will be created
#' @param after is set to 1 by default, it means that the varying part will be after the fixed part, set to 0 if you want the varying part to be before 
#' @param nb is the number of random pattern chosen for the varying part
#' @param sep is the separator between all patterns in the returned value
#' @export

pattern_generator <- function(base_, from_, nb, hmn=1, after=1, sep=""){
  
  rtnl <- c()
  
  base_ <- unlist(str_split(base_, ""))
  
  base2_ <- base_
  
  for (I in 1:hmn){
    
    for (i in 1:nb){
      
      idx <- round(runif(1, 1, length(from_)), 0)
      
      if (after == 1){
        
        base_ <- append(base_, from_[idx])
        
      }else{
        
        base_ <- append(base_, from_[idx], after=0)
        
      }
      
    }
    
    base_ <- stri_paste(base_, collapse=sep)
    
    rtnl <- append(rtnl, base_)
    
    base_ <- base2_
    
  }
  
  return(rtnl)
  
}

#' pattern_tuning
#'
#' Allow to tune a pattern very precisely and output a vector containing its variations n times.
#' @param pattrn is the character that will be tuned 
#' @param spe_nb is the number of new character that will be replaced
#' @param spe_l is the source vector from which the new characters will replace old ones
#' @param exclude_type is character that won't be replaced
#' @param hmn is how many output the function will return
#' @param rg is a vector with two parameters (index of the first letter that will be replaced, index of the last letter that will be replaced) default is set to all the letters from the source pattern
#' @export

pattern_tuning <- function(pattrn, spe_nb, spe_l, exclude_type, hmn=1, rg=c(0, 0)){
  
  lngth <- nchar(pattrn)
  
  if (rg[2] == 0){
    
    rg[2] = lngth
    
  }
  
  rtnl <- c()
  
  if (spe_nb < lngth | rg[1] < 0 | rg[2] > lngth){
    
    pattrn2 <- unlist(str_split(pattrn, ""))
    
    pattrn_l <- c()
    
    for (i in 1:lngth){
      
      pattrn_l <- append(pattrn_l, pattrn2[i])
      
    }
    
    pattrn <- pattrn_l
    
    b_l <- c()
    
    for (i in rg[1]:rg[2]){
      
      if (pattrn[i] %in% spe_l){
        
        b_l <- append(b_l, T)
        
      }else{
        
        b_l <- append(b_l, F)
        
      }
      
    }
    
    spe_nb_obj = sum(b_l)
    
    spe_nb_obj2 <- spe_nb_obj
    
    if (all(b_l) == F){
      
      for (I in 1:hmn){ 
        
        while (spe_nb_obj < spe_nb){
          
          if (rg[2] == lngth & rg[1] == 0){
            
            idx <- round(runif(1, 1, lngth), 0)
            
          }else{
            
            idx <- round(runif(1, rg[1], rg[2]), 0)
            
          }
          
          if (sum(grepl(pattrn[idx], spe_l)) == 0 & sum(grepl(pattrn[idx], exclude_type)) == 0){
            
            pattrn[idx] <- spe_l[round(runif(1, 1, length(spe_l)), 0)]
            
            spe_nb_obj = spe_nb_obj + 1
            
          }
          
        }
        
        spe_nb_obj = spe_nb_obj2
        
        pattrn <- stri_paste(pattrn, collapse="")
        
        rtnl <- append(rtnl, pattrn)
        
        pattrn <- pattrn_l 
        
      }
      
    }
    
    return(rtnl)
    
  }else{
    
    print("word too short for your arguments, see the documentation")
    
  }
  
}

#' can_be_num
#'
#' Return TRUE if a variable can be converted to a number and FALSE if not (supports float)
#' @param x is the input value
#' @export

can_be_num <- function(x){

    if (typeof(x) == "double"){

            return(T)

    }else{

        vec_bool <- c()

        v_ref <- c("1", "2", "3", "4", "5", "6", "7", "8", "9", "0", ".")    

        v_wrk <- unlist(str_split(x, ""), v_ref)

        for (i in 1:length(v_wrk)){ 

                if (v_wrk[i] == "."){ 

                        vec_bool <- append(vec_bool, sum(grepl("\\.", v_ref))) 

                }else{

                        vec_bool <- append(vec_bool, sum(grepl(v_wrk[i], v_ref))) 

                }

        }

        if (sum(vec_bool) == length(vec_bool)){

                return(T)

        }else{

                return(F)

        }

    }

}

#' unique_pos
#'
#' Allow to find indexes of the unique values from a vector. 
#' @param vec is the input vector
#' @export

unique_pos <- function(vec){

        u_vec <- unique(vec)

        return(match(u_vec, vec))

}


#' data_gen
#'
#' Allo to generate in a csv all kind of data you can imagine according to what you provide
#' @param type_ is a vector for wich argument is a column, a column can be made of numbers ("number"), string ("string") or both ("mixed")
#' @param strt_l is a vector containing for each column the row from which the data will begin to be generated
#' @param nb_r is a vector containing for each column, the number of row full from generated data  
#' @param output is the name of the output csv file
#' @param type_distri is a vector which, for each column, associate a type of distribution ("random", "poisson", "gaussian"), it meas that non only the number but also the length of the string will be randomly generated according to these distribution laws
#' @param properties is linked to type_distri because it is the parameters ("min_val-max_val") for "random type", ("u-x") for the poisson distribution, ("u-d") for gaussian distribution
#' @param str_source is the source (vector) from which the character creating random string are (default set to the occidental alphabet)
#' @param round_l is a vector which, for each column containing number, associate a round value
#' @param sep_ is the separator used to write data in the csv
#' @return new generated data in addition to saving it in the output
#' @export

data_gen <- function(type_=c("number", "mixed", "string"), strt_l=c(0, 0, 10), nb_r=c(50, 10, 40), output="gened.csv", 
                     properties=c("1-5", "1-5", "1-5"), type_distri=c("random", "random", "random"), 
                     str_source=c("a", "b", "c", "d", "e", "f", "g", 
                                  "h", "i", "j", "k", "l", "m", 
                                  "n", "o", "p", "q", "r", "s", "t", "u", "w", "x", "y", "z"), 
                     round_l=c(0, 0, 0), sep_=","){
  
  v_get1 <- c()
  
  v_get2 <- c()
  
  delta_ <- c()
  
  for (i in 1:length(properties)){
    
    v_get1 <- append(v_get1, unlist(str_split(properties[i], "-"))[1])
    
    v_get2 <- append(v_get2, unlist(str_split(properties[i], "-"))[2])
    
    delta_ <- append(delta_, (strt_l[i] + nb_r[i]))
    
  }
  
  v_get1 <- as.numeric(v_get1)
  
  v_get2 <- as.numeric(v_get2)
  
  rtnl <- data.frame(matrix(NA, nrow=max(delta_), ncol=length(type_)))
  
  for (I in 1:length(type_)){
    
    if (type_[I] == "mixed"){
      
      for (i in strt_l[I]:(nb_r[I]+strt_l[I])){
        
        str_ <- round(runif(1, 0, 1), 0)
        
        if (str_ == 1){
          
          if (type_distri[I] == "random"){
            
            add_ <- round(runif(1, v_get1[I], v_get2[I]), 0)
            
            if (add_ > length(str_source)){
              
              add_ <- length(str_source)
              
            }
            
            rtnl[i, I] <- stri_paste(str_source[1:add_], collapse="")
            
          }
          
          if (type_distri[I] == "poisson"){
            
            add_ <- round(dpois(v_get1[I], v_get2[I]), 0)
            
            if (add_ > length(str_source)){
              
              add_ <- length(str_source)
              
            }
            
            rtnl[i, I] <- stri_paste(str_source[1:add_], collapse="")
            
          }
          
          if (type_distri[I] == "gaussian"){
            
            add_ <- round(runif(1, v_get1[I], v_get2[I]), 0)
            
            if (add_ > length(str_source)){
              
              add_ <- length(str_source)
              
            }
            
            rtnl[i, I] <- stri_paste(str_source[1:add_], collapse="")
            
          }
          
        }else{
          
          
          if (type_distri[I] == "random"){
            
            add_ <- round(runif(1, v_get1[I], v_get2[I]), round_l[I])
            
            rtnl[i, I] <- add_
            
          }
          
          if (type_distri[I] == "poisson"){
            
            add_ <- round(dpois(v_get1[I], v_get2[I]), round_l[I]) 
            
            rtnl[i, I] <- add_
            
          }
          
          if (type_distri[I] == "gaussian"){
            
            add_ <- round(dnorm(v_get1[I], v_get2[I]), round_l[I])
            
            rtnl[i, I] <- add_
            
          }
          
          
        }
        
      }
      
    }
    
    if (type_[I] == "string"){
      
      for (i in strt_l[I]:(nb_r[I]+strt_l[I])){
        
        if (type_distri[I] == "random"){
          
          add_ <- round(runif(1, v_get1[I], v_get2[I]), 0)
          
          if (add_ > length(str_source)){
            
            add_ <- length(str_source)
            
          }
          
          rtnl[i, I] <- stri_paste(str_source[1:add_], collapse="")
          
        }
        
        if (type_distri[I] == "poisson"){
          
          add_ <- round(dpois(v_get1[I], v_get2[I]), 0)
          
          if (add_ > length(str_source)){
            
            add_ <- length(str_source)
            
          }
          
          rtnl[i, I] <- stri_paste(str_source[1:add_], collapse="")
          
        }
        
        if (type_distri[I] == "gaussian"){
          
          add_ <- round(runif(1, v_get1[I], v_get2[I]), 0)
          
          if (add_ > length(str_source)){
            
            add_ <- length(str_source)
            
          }
          
          rtnl[i, I] <- stri_paste(str_source[1:add_], collapse="")
          
        }
        
      }
      
    }
    
    if (type_[I] == "number"){
      
      for (i in strt_l[I]:(nb_r[I]+strt_l[I])){
        
        if (type_distri[I] == "random"){
          
          add_ <- round(runif(1, v_get1[I], v_get2[I]), round_l[I])
          
          rtnl[i, I] <- add_
          
        }
        
        if (type_distri[I] == "poisson"){
          
          add_ <- round(dpois(v_get1[I], v_get2[I]), round_l[I]) 
          
          rtnl[i, I] <- add_
          
        }
        
        if (type_distri[I] == "gaussian"){
          
          add_ <- round(dnorm(v_get1[I], v_get2[I]), round_l[I])
          
          rtnl[i, I] <- add_
          
        }
        
      }
      
    }
    
  }
  
  if (is.na(output) == F){
    
    write.table(rtnl, output, sep=sep_, row.names=F, col.names=F)
    
  }
  
  return(rtnl)
  
}

#' data_meshup
#'
#' Allow to automatically arrange 1 dimensional data according to vector and parameters
#' @param data is the data provided (vector) each column is separated by a unic separator and each dataset from the same column is separated by another unic separator (ex: c("_", c("d", "-", "e", "-", "f"), "_", c("a", "a1", "-", "b", "-", "c", "c1")"_")
#' @param cols is the colnames of the data generated in a csv
#' @param file_ is the file to which the data will be outputed
#' @param sep_ is the separator of the csv outputed
#' @param organisation is the way variables include themselves, for instance ,resuming precedent example, if organisation=c(1, 0) so the data output will be:
#' d, a
#' d, a1
#' e, c
#' f, c
#' f, c1
#' @param unic_sep1 is the unic separator between variables (default is "_")
#' @param unic_sep2 is the unic separator between datasets (default is "-")
#' @export

data_meshup <- function(data, cols=NA, file_=NA, sep_=";", 
                        organisation=c(2, 1, 0), unic_sep1="_", 
                        unic_sep2="-"){
  
  l_l <- c()
  
  l_lngth <- c()
  
  old_max_row <- -1
  
  sep_dd <- str_detect(data, unic_sep1)
  
  jsq <- sum(sep_dd[!is.na(sep_dd)]) - 1 #numb of var
  
  sep_dd <- str_detect(data, unic_sep2)
  
  hmn <- (sum(sep_dd[!is.na(sep_dd)]) / jsq) #numb of datasets
  
  val_nb <- length(data) - (hmn * jsq + (jsq + 1))  
  
  dataset_l <- which(str_detect("-", data))
  
  df <- data.frame(matrix(nrow = val_nb, ncol = jsq))
  
  for (I in 1:hmn){
    
    idx_s = 0
    
    seq_l <- seq(I, length(dataset_l), hmn)
    
    for (i in 1:jsq){
      
      idx <- dataset_l[seq_l[i]]
      
      t = 1
      
      sep_dd <- grepl(data[idx + t], c(unic_sep2, unic_sep1))
      
      while(sum(sep_dd[!is.na(sep_dd)]) == 0 & (idx + t <= length(data)) == T){
        
        l_l <- append(l_l, data[idx + t])
        
        t = t + 1
        
        sep_dd <- grepl(data[idx + t], c("-", "_"))
        
      }
      
      l_lngth <- append(l_lngth, (t - 1))
      
      df[1:length(l_l), i] <- l_l
      
      l_l <- c()
      
    }
    
    if (old_max_row == -1){
      
      df2 <- data.frame(matrix(nrow=0, ncol=jsq))
      
    }
    
    old_max_row <- max(l_lngth, na.rm=T)
    
    l_lngth <- c()
    
    for (i in 1:jsq){
      
      v_rel <- df[, i]
      
      var_ = 1
      
      x = 1
      
      while (x <= organisation[i]){
        
        v_relb <- df[, i + x]
        
        val_ <- v_rel[var_] # val to be added
        
        for (t in 1:length(v_relb[!is.na(v_relb)])){
          
          df[t, i] <- val_ 
          
          if (t + 1 <= length(v_rel)){
            
            if (is.na(v_rel[t + 1]) == F){
              
              var_ = var_ + 1 
              
              while (is.na(v_rel[var_]) == T){
                
                var_ = var_ + 1 
                
              }
              
              val_ <- v_rel[var_]  
              
            }
            
          }
          
        }
        
        x = x + 1
        
      }
      
    }
    
    df2 <- rbind(df2, df[1:old_max_row, 1:jsq])
    
    df[1:nrow(df), 1:ncol(df)] = NA
    
  }
  
  if (all(is.na(cols)) == F){
    
    colnames(df2) <- cols
    
  }
  
  if (is.na(file_)){
    
    return(df2)
    
  }else{
    
    write.table(df2, file_, sep=sep_, row.names=F)
    
  }
  
}

#' letter_to_nb
#'
#' Allow to get the number of a spreadsheet based column by the letter ex: AAA = 703
#' @param letter is the letter (name of the column)
#' @export

letter_to_nb <- function(letter){
  
  l <- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", 
         "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z")
  
  nb = 0
  
  nch <- nchar(letter) - 1
  
  for (i in 0:nch){
    
    x <- str_sub(letter, nchar(letter) - i, nchar(letter) - i)
    
    x <- tolower(x)
    
    nb <- nb + match(x, l) * 26 ** i
    
  }
  
  return(nb)
  
}

#' nb_to_letter
#'
#' Allow to get the letter of a spreadsheet based column by the number ex: 703 = AAA
#' @param x is the number of the column 
#' @export

nb_to_letter <- function(x){
  
  l <- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", 
         "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z")
  
  rtnl  <- c()
  
  x_l <- c()
  
  r_l <- c()
  
  abc_l <- c()
  
  t = 1
  
  add_ <- 1
  
  reste <- 0
  
  while (x %/% add_ > 0){
    
    r_l <- append(r_l, reste)
    
    x_l <- append(x_l, add_)
    
    add_ <- 26 ** t
    
    reste <- x %% add_
    
    t = t + 1
    
  }
  
  for (i in 1:length(x_l)){
    
    idx <- length(x_l) - (i - 1)
    
    add_ <- x %/% x_l[idx]
    
    rtnl <- append(rtnl, l[add_])
    
    x <- r_l[idx]
    
  }
  
  rtnl <- paste(rtnl, collapse="")
  
  return(rtnl)
  
}

#' cost_and_taxes
#'
#' Allow to calculate basic variables related to cost and taxes from a bunch of products (elements)
#' So put every variable you know in the following order:
#' @param qte is the quantity of elements
#' @param pu is the price of a single elements without taxes
#' @param prix_ht is the duty-free price of the whole set of elements
#' @param tva is the percentage of all taxes
#' @param prix_ttc is the price of all the elements with taxes
#' @param prix_tva is the cost of all the taxes
#' @param pu_ttc is the price of a single element taxes included
#' @param adjust is the discount percentage
#' @param prix_d_ht is the free-duty price of an element after discount
#' @param prix_d_ttc is the price with taxes of an element after discount
#' @param pu_d is the price of a single element after discount and without taxes
#' @param pu_d_ttc is the free-duty price of a single element after discount
#' the function return a vector with the previous variables in the same order
#' those that could not be calculated will be represented with NA value
#' @export

cost_and_taxes <- function(qte=NA, pu=NA, prix_ht=NA, tva=NA, prix_ttc=NA,
                           prix_tva=NA, pu_ttc=NA, adjust=NA, prix_d_ht=NA,
                           prix_d_ttc=NA, pu_d=NA, pu_d_ttc=NA){
  
  val_l <- c(qte, pu, prix_ht, tva, prix_ttc, prix_tva, pu_ttc, adjust,
             prix_d_ht, prix_d_ttc, pu_d, pu_d_ttc)
  
  already <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  
  rtnl <- c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)
  
  for (i in 1:length(already)){
    
    if (is.na(val_l[i]) == F){
      
      already[i] <- 1
      
      rtnl[i] <- val_l[i]
      
    }
    
  }
  
  for (i in 1:16){
    
    if (is.na(prix_ttc) == F & is.na(prix_d_ttc) == F & already[8] == 0){
      
      adjust <- prix_ttc / prix_d_ttc - 1
      
      already[8] <- 1
      
      rtnl[8] <- adjust
      
    }

    if (is.na(prix_ht) == F & is.na(prix_d_ht) == F & already[8] == 0){
      
      adjust <- prix_ht / prix_d_ht - 1
      
      already[8] <- 1
      
      rtnl[8] <- adjust
      
    }
    
    if (is.na(pu_ttc) == F & is.na(pu_d_ttc) == F & already[8] == 0){
      
      adjust <- pu_ttc / pu_d_tcc - 1
      
      already[8] <- 1
      
      rtnl[8] <- adjust
      
    }

    if (is.na(pu) == F & is.na(pu_d) == F & already[8] == 0){
      
      adjust <- pu / pu_d - 1
      
      already[8] <- 1
      
      rtnl[8] <- adjust
      
    }

    if (is.na(qte) == F & is.na(pu_d) == 0 & already[9] == 0){
      
      prix_d_ht <- qte * pu_d
      
      already[9] <- 0
      
      rtnl[9] <- prix_d_ht
      
    }
    
    if (is.na(qte) == F & is.na(pu_d_ttc) == 0 & already[10] == 0){
      
      prix_d_ttc <- qte * pu_d_ttc
      
      already[10] <- 0
      
      rtnl[10] <- prix_d_ht
      
    }
    
    if (is.na(prix_d_ttc) == F & is.na(qte) == F & already[12] == 0){
      
      pu_d_ttc <- prix_d_ttc / qte
      
      already[12] <- 1
      
      rtnl[12] <- pu_d_ttc
      
    }
    
    if (is.na(prix_d_ht) == F & is.na(qte) == F & already[11] == 0){
      
      pu_d <- prix_d_ht / qte
      
      already[11] <- 1
      
      rtnl[11] <- pu_d
      
    }
    
    if (is.na(adjust) == F & is.na(prix_ttc) == F & already[10] == 0){
      
      prix_d_ttc <- prix_ttc * (1 - adjust)
      
      already[10] <- 1
      
      rtnl[10] <- prix_d_ttc
      
    }
    
    if (is.na(adjust) == F & is.na(prix_ht) == F & already[9] == 0){
      
      prix_d_ht <- prix_ht * (1 - adjust)
      
      already[9] <- 1
      
      rtnl[9] <- prix_d_ht
      
    }
    
    if (is.na(adjust) == F & is.na(prix_d_ht) == F & already[3] == 0){
      
      prix_ht <- prix_d_ht * (1 / (1 - adjust))
      
      already[3] <- 1
      
      rtnl[3] <- prix_ht
      
    }
    
    if (is.na(adjust) == F & is.na(prix_d_ttc) == F & already[5] == 0){
      
      prix_ttc <- prix_d_ttc * (1 / (1 - adjust))
      
      already[5] <- 1
      
      rtnl[5] <- prix_ttc
      
    }
    
    if (is.na(pu) == F & is.na(pu_ttc) == F & already[4] == 0){
      
      tva <- pu_ttc / pu - 1
      
      already[4] <- 1
      
      rtnl[4] <- tva
      
    }

    if (is.na(pu_d_ttc) == F & is.na(pu_d) == F & already[4] == 0){
      
      tva <- pu_d_ttc / pu_d - 1
      
      already[4] <- 1
      
      rtnl[4] <- tva
      
    }

    if (is.na(prix_d_ttc) == F & is.na(prix_d_ht) == F & already[4] == 0){
      
      tva <- prix_d_ttc / prix_d_ht - 1
      
      already[4] <- 1
      
      rtnl[4] <- tva
      
    }
    
    if (is.na(prix_ht) == F & is.na(pu) == F & already[1] == 0){
      
      qte <- prix_ht / pu
      
      rtnl[1] <- as.integer(qte)
      
      already[1] <- 1
      
    }
    
    if (is.na(prix_ttc) == F & is.na(pu_ttc) == F & already[1] == 0){
      
      qte <- prix_ttc / pu_ttc
      
      rtnl[1] <- as.integer(qte)
      
      already[1] <- 1
      
    }
    
    if (is.na(prix_d_ht) == F & is.na(pu_d) == F & already[1] == 0){
      
      qte <- prix_d_ht / pu_d
      
      rtnl[1] <- as.integer(qte)
      
      already[1] <- 1
      
    }
    
    if (is.na(prix_d_ttc) == F & is.na(pu_d_ttc) == F & already[1] == 0){
      
      qte <- prix_d_ttc / pu_d_ttc
      
      rtnl[1] <- as.integer(qte)
      
      already[1] <- 1
      
    }
    
    if (is.na(prix_ht) == F & is.na(qte) == F & already[2] == 0){
      
      pu <- prix_ht / qte
      
      rtnl[2] <- pu
      
      already[2] <- 1
      
    }
    
    if (is.na(prix_ttc) == F & is.na(qte) == F & already[7] == 0){
      
      pu_ttc <- prix_ttc / qte
      
      rtnl[7] <- pu
      
      already[7] <- 1
      
    }
    
    if (is.na(pu) == F & is.na(qte) == F & already[3] == 0){
      
      prix_ht <- pu * qte
      
      rtnl[3] <- pu
      
      already[3] <- 1
      
    }
    
    if (is.na(pu_ttc) == F & is.na(qte) == F & already[5] == 0){
      
      prix_ttc <- pu_ttc * qte
      
      rtnl[5] <- pu
      
      already[5] <- 1
      
    }
    
    if (is.na(pu) == F & is.na(qte) == F & already[3] == 0){
      
      prix_ht <- pu * qte
      
      rtnl[3] <- prix_ht
      
      already[3] <- 1
      
    }
    
    if (is.na(prix_ht) == F & is.na(prix_ttc) == F & already[4] == 0){
      
      tva <- prix_ttc / prix_ht - 1
      
      rtnl[4] <- tva
      
      already[4] <- 1
      
    }
    
    if (is.na(tva) == F & is.na(prix_ttc) == F & already[3] == 0){
      
      prix_ht <- prix_ttc / (1 + tva)
      
      rtnl[3] <- prix_ht
      
      already[3] <- 1
      
    }
    
    if (is.na(tva) == F & is.na(prix_ht) == F & already[5] == 0){
      
      prix_ttc <- prix_ht * (1 + tva) 
      
      rtnl[5] <- prix_ttc
      
      already[5] <- 1
      
    }  
    
    if (is.na(prix_ht) == F & is.na(prix_ttc) == F & already[6] == 0){
      
      prix_tva <- prix_ttc - prix_ht
      
      rtnl[6] <- prix_tva
      
      already[6] <- 1
      
    }
    
    if (is.na(tva) == F & is.na(prix_ttc) == F & already[6] == 0){
      
      prix_tva <- tva * prix_ht
      
      rtnl[6] <- prix_tva
      
      already[6] <- 1
      
    }
    
  }
  
  return(rtnl)
  
}

# xx-month-xxxx -> xx-xx-xxxx

#' format_date
#'
#' Allow to convert xx-month-xxxx date type to xx-xx-xxxx
#' @param f_dialect are the months from the language of which the month come
#' @param sentc is the date to convert
#' @param sep_in is the separator of the dat input (default is "-")
#' @param sep_out is the separator of the converted date (default is "-")
#' @export

format_date <- function(f_dialect, sentc, sep_in="-", sep_out="-"){
  
  traduct <- f_dialect
  
  x <- unlist(str_split(sentc, sep_in))
  
  x2 <- match(x[2], f_dialect)
  
  x2 <- as.character(x2)

  if (nchar(x2) == 1){

    x2 <- paste0("0", x2)
  
  }

  x <- paste0(x[1], sep_out, x2, sep_out, x[3]) 
  
  return(x)
  
}

#' until_stnl
#'
#' Maxes a vector to a chosen length 
#' ex: if i want my vector c(1, 2) to be 5 of length this function will return me: c(1, 2, 1, 2, 1) 
#' @param vec1 is the input vector
#' @param goal is the length to reach
#' @export

until_stnl <- function(vec1, goal){

  max_ = 0

  ld <- length(vec1)

  for (i in (length(vec1)+1):goal){

        if (max_ < ld){

                max_ = max_ + 1 

        }else{

                max_ = 1

        }

        vec1 <- append(vec1, vec1[max_])

  }

  return(vec1)

}

#' vlookup_df
#'
#' Alow to perform a vlookup on a dataframe
#' @param df is the input dataframe
#' @param v_id is a vector containing the ids
#' @param col_id is the column that contains the ids (default is equal to 1)
#' @param included_col_id is if the result should return the col_id (default set to yes) 
#' @export

vlookup_df <- function(df, v_id, col_id=1, included_col_id="yes"){
  
  rtnl <- df[1, ]
  
  for (i in 1:length(v_id)){

    idx = match(v_id[i], df[, col_id])
    
    rtnl <- rbind(rtnl, df[idx,])
    
    df <- df[-idx, ]
    
  }
  
  if (included_col_id == "yes"){
  
    return(rtnl[-1, ])
  
  }else{
    
    return(rtnl[-1, -col_id])
    
  }
    
}

#' multitud
#'
#' From a list containing vectors allow to generate a vector following this rule:
#' list(c("a", "b"), c("1", "2"), c("A", "Z", "E")) --> c("a1A", "a2A", "b1A", "b2A", "a1Z", ...)
#' @param l is the list
#' @param sep_ is the separator between elements (default is set to "" as you see in the example)
#' @export

multitud <- function(l, sep_=""){
  
  rtnl <- unlist(l[1])
  
  for (I in 2:length(l)){
    
    rtnl2 <- c()
    
    cur_ <- unlist(l[I])
    
    for (i in 1:length(cur_)){
      
      for (t in 1:length(rtnl)){
        
        rtnl2 <- append(rtnl2, paste(rtnl[t] , cur_[i], sep=sep_))
        
      }
      
    }
    
    rtnl <- rtnl2
    
  }
  
  return(rtnl)
  
}

#' df_tuned 
#'
#' Allow to return a list from a dataframe following these rules:
#' First situation, I want the vectors from the returned list be composed of values that are separated by special values contained in a vector 
#' ex: data.frame(c(1, 1, 2, 1), c(1, 1, 2, 1), c(1, 1, 1, 2)) will return list(c(1, 1), c(1, 1, 1), c(1, 1, 1, 1)) or 
#' list(c(1, 1, 2), c(1, 1, 1, 2), c(1, 1, 1, 1, 2)) if i have chosen to take in count the 2. As you noticed here the value to stop is 2 but it can be several contained in a vector
#' Second situation: I want to return a list for every jump of 3.
#' If i take this dataframe data.frame(c(1, 1, 2, 1, 4, 4), c(1, 1, 2, 1, 3, 3), c(1, 1, 1, 2, 3, 3)) it will return list(c(1, 1, 2), c(1, 4, 4), c(1, 1, 2), c(1, 3, 3), c(1, 1, 1), c(2, 3, 3)) 
#' @param df is the input data.frame
#' @param val_to_stop is the vector containing the values to stop
#' @param index_rc is the value for the jump (default set to NA so default will be first case)
#' @param included is if the values to stop has to be also returned in the vectors (defaultn set to "yes")
#' @export

df_tuned <- function(df, val_to_stop, index_rc=NA, included="yes"){

 rtnl_l <- list()

 for (I in 1:ncol(df)){

        rtnl <- c()

        t = 1

        while (t <= nrow(df)){

                if (is.na(index_rc) == T){

                        while (!(df[t, I] %in% val_to_stop) == T & t <= nrow(df)){

                                rtnl <- append(rtnl, df[t, I])

                                t = t + 1

                        }

                        if (df[t, I] %in% val_to_stop & included == "yes"){ 

                                rtnl_l <- append(rtnl_l, data.frame(rtnl)) 

                                rtnl <- c()

                        }

                }else{

                        while (t %% index_rc != 0 & t <= nrow(df)){

                                rtnl <- append(rtnl, df[t, I])

                                t = t + 1

                        }

                        if (t %% index_rc == 0){

                                if (included == "yes"){ rtnl <- append(rtnl, df[t, I]) }

                                rtnl_l <- append(rtnl_l, data.frame(rtnl))

                                rtnl <- c()

                        }

                }

                t = t + 1

        }

 }

 return(rtnl_l)

}

#' see_df
#' 
#' Allow to return a dataframe with special value cells (ex: TRUE) where the condition entered are respected and another special value cell (ex: FALSE) where these are not
#' @param df is the input dataframe
#' @param condition_l is the vector of the possible conditions ("==", ">", "<", "!=", "%%") (equal, greater than, lower than, not equal to, is divisible by), you can put the same condition n times. 
#' @param val_l is the list of vectors containing the values related to condition_l (so the vector of values has to be placed in the same order)
#' @param conjunction_l contains the | or & conjunctions, so if the length of condition_l is equal to 3, there will be 2 conjunctions. If the length of conjunction_l is inferior to the length of condition_l minus 1, conjunction_l will match its goal length value with its last argument as the last arguments. For example, c("&", "|", "&") with a goal length value of 5 --> c("&", "|", "&", "&", "&")
#' @param rt_val is a special value cell returned when the conditions are respected
#' @param f_val is a special value cell returned when the conditions are not respected
#' @details This function will return an error if number only comparative conditions are given in addition to having character values in the input dataframe.
#' @export

see_df <- function(df, condition_l, val_l, conjunction_l=c(), rt_val=T, f_val=F){

        if (length(condition_l) > 1 & length(conjunction_l) < (length(condition_l) - 1)){

                for (i in (length(conjunction_l)+1):length(condiction_l)){

                        conjunction_l <- append(conjunction_l, conjunction_l[length(conjunction_l)])

                }

        }

        df_rtnl <- data.frame(matrix(f_val, ncol=ncol(df), nrow=nrow(df)))

        all_op <- c("==", ">", "<", "!=", "%%")

        for (I in 1:ncol(df)){

                for (i in 1:nrow(df)){

                        checked_l <- c()

                        previous = 1

                        for (t in 1:length(condition_l)){

                                already <- 0

                                if (condition_l[t] == "==" & already == 0){

                                        if (df[i, I] %in% unlist(val_l[t])){

                                                checked_l <- append(checked_l, T)

                                                if (length(condition_l) > 1 & t > 1){

                                                        bfr <- conjunction_l[previous:t]

                                                        if (t == length(condition_l)){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }else if (conjunction_l[t] == "|"){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }

                                                }else if (length(condition_l) == 1){

                                                        df_rtnl[i, I] <- rt_val

                                                }else {

                                                        if (conjunction_l[1] == "|"){

                                                                df_rtnl[i, I] <- rt_val

                                                                checked_l <- c()

                                                        }

                                                }

                                        }

                                        if (t <= length(conjunction_l)){ 

                                                if (conjunction_l[t] == "|"){

                                                        checked_l <- c()

                                                        previous = t + 1 

                                                }

                                        }

                                }

                                if (condition_l[t] == ">" & already == 0){

                                        if (all(df[i, I] > unlist(val_l[t])) == T){

                                                checked_l <- append(checked_l, T)

                                                if (length(condition_l) > 1 & t > 1){

                                                        bfr <- conjunction_l[previous:t]

                                                        if (t == length(condition_l)){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }else if (conjunction_l[t] == "|"){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }

                                                }else if (length(condition_l) == 1){

                                                        df_rtnl[i, I] <- rt_val

                                                }else {

                                                        if (conjunction_l[1] == "|"){

                                                                df_rtnl[i, I] <- rt_val

                                                                checked_l <- c()

                                                        }

                                                }

                                        }

                                        if (t <= length(conjunction_l)){ 

                                                if (conjunction_l[t] == "|"){

                                                        checked_l <- c()

                                                        previous = t + 1 

                                                }

                                        }

                                }

                                if (condition_l[t] == "<" & already == 0){

                                        if (all(df[i, I] < unlist(val_l[t]))){

                                                checked_l <- append(checked_l, T)

                                                if (length(condition_l) > 1 & t > 1){

                                                        bfr <- conjunction_l[previous:t]

                                                        if (t == length(condition_l)){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }else if (conjunction_l[t] == "|"){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }

                                                }else if (length(condition_l) == 1){

                                                        df_rtnl[i, I] <- rt_val

                                                }else {

                                                        if (conjunction_l[1] == "|"){

                                                                df_rtnl[i, I] <- rt_val

                                                                checked_l <- c()

                                                        }

                                                }

                                        }

                                        if (t <= length(conjunction_l)){ 

                                                if (conjunction_l[t] == "|"){

                                                        checked_l <- c()

                                                        previous = t + 1 

                                                }

                                        }

                                }

                                if (condition_l[t] == "!=" & already == 0){

                                        if (!(df[i, I] %in% unlist(val_l[t])) == T){

                                                checked_l <- append(checked_l, T)

                                                if (length(condition_l) > 1 & t > 1){

                                                        bfr <- conjunction_l[previous:t]

                                                        if (t == length(condition_l)){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }else if (conjunction_l[t] == "|"){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }

                                                }else if (length(condition_l) == 1){

                                                        df_rtnl[i, I] <- rt_val

                                                }else {

                                                        if (conjunction_l[1] == "|"){

                                                                df_rtnl[i, I] <- rt_val

                                                                checked_l <- c()

                                                        }

                                                }

                                        }

                                        if (t <= length(conjunction_l)){ 

                                                if (conjunction_l[t] == "|"){

                                                        checked_l <- c()

                                                        previous = t + 1 

                                                }

                                        }

                                }

                                if (condition_l[t] == "%%" & already == 0){

                                        if (sum(df[i, I] %% unlist(val_l[t])) == 0){

                                                checked_l <- append(checked_l, T)

                                                if (length(condition_l) > 1 & t > 1){

                                                        bfr <- conjunction_l[previous:t]

                                                        if (t == length(condition_l)){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }else if (conjunction_l[t] == "|"){

                                                                if (length(checked_l) == length(bfr)){

                                                                        already <- 1

                                                                        df_rtnl[i, I] <- rt_val

                                                                }

                                                        }

                                                }else if (length(condition_l) == 1){

                                                        df_rtnl[i, I] <- rt_val

                                                }else {

                                                        if (conjunction_l[1] == "|"){

                                                                df_rtnl[i, I] <- rt_val

                                                                checked_l <- c()

                                                        }

                                                }

                                        }

                                        if (t <= length(conjunction_l)){ 

                                                if (conjunction_l[t] == "|"){

                                                        checked_l <- c()

                                                        previous = t + 1 

                                                }

                                        }

                                }

                        }
                        
                }

        }

  return(df_rtnl)

}

#' days_from_month
#'
#' Allow to find the number of days month from a month date, take in count leap year 
#' @param date_ is the input date
#' @param sep_ is the separator of the input date
#' @export

days_from_month <- function(date_, sep_){
  
  can.be.numeric <- function(x) {
    
    numNAs <- sum(is.na(x))
    
    numNAs_new <- suppressWarnings(sum(is.na(as.numeric(x))))
    
    return(numNAs_new == numNAs)
    
  }
  
  x <- unlist(str_split(date_, sep_))
  
  month <- x[2]

  year <- x[length(x)]
  
  year <- as.numeric(year)
  
  if (year %% 4 == 0){
    
    if (year %% 100 == 0){
      
      if (year %% 400 == 0){
        
        bsx <- T
        
      }else{
        
        bsx <- F
        
      }
      
    }else{
      
      bsx <- T
      
    }
    
  }else{
    
    bsx <- F
    
  }
  
  l_nm <- c(31, 00, 31, 30, 31, 30, 31, 31,
            30, 31, 30, 31)
  
  if (can.be.numeric(month) == T){
    
    nm <- as.numeric(month)
    
    month <- dialect[nm]
    
    indx <- match(month, dialect)
    
    rtnl <- l_nm[indx]
    
  }else{
    
    indx <- match(month, dialect)
    
    rtnl <- l_nm[indx]
    
  }
  
  if (rtnl == 00){
    
    if (bsx == T){
      
      rtnl <- 29
      
    }else{
      
      rtnl <- 28
      
    }
    
  }
  
  return(rtnl)
  
}

#' vec_in_df
#'
#' Allow to see if vectors are present in a dataframe
#'ex: 1, 2, 1
#'    3, 4, 1
#'    1, 5, 8
#' the vector c(4, 1) with the coefficient 1 and the start position at the second column is containded in the dataframe
#' @param df_ is the input dataframe
#' @param vec_l is a list the vectors
#' @param coeff_ is the related coefficient of the vector
#' @param strt_l is a vector containing the start position for each vector
#' @param distinct is a value you are sure is not in df_, defaults to "NA" 
#' @export

vec_in_df <- function(df_, vec_l, coeff_, strt_l, distinct="NA"){

        rtnl_f <- c()

        rtnl_pos_f <- c()

        hmn_lf <- c()

        for (I in 1:length(vec_l)){

                vec <- unlist(vec_l[I])

                rtnl <- c()

                rtnl_pos <- c()

                hmn_l <- c()
                
                indx_l <- which(df_[1:nrow(df_), strt_l[I]] == vec[1])

                btm = indx_l[1] 

                top = indx_l[length(indx_l)]

                indx_l <- which(df_[btm:top, strt_l[I]] == vec[1])

                v_previous <- indx_l

                if (length(indx_l) > 0){

                        rtnl <- append(rtnl, vec[1])

                }else{

                        rtnl <- append(rtnl, distinct)

                }

                y = 1

                while (y <= length(indx_l)){

                        if (!(indx_l[y] %in% v_previous) == T){

                                indx_l <- indx_l[-y]

                        }

                        y = y + 1

                }

                ti = 2

                for (i in (strt_l[I]+1):(strt_l[I]+length(vec) - 1)){ 

                        if (btm + coeff_[I] > 0 & btm + coeff_[I] <= nrow(df_)){

                                btm = btm + coeff_[I]
                       
                        }else{

                                btm = 1

                        }

                        if (top + coeff_[I] > 0 & top + coeff_[I] <= nrow(df_)){

                                top = top + coeff_[I]

                        }else{ 

                                top = nrow(df_) 

                        }

                        indx_l <- which(df_[btm:top, i] == vec[ti]) 

                        if (length(indx_l) > 0){

                                rtnl <- append(rtnl, vec[ti])

                        }else{

                                rtnl <- append(rtnl, distinct)

                        }

                        y = 1

                        while (y <= length(indx_l)){

                                if (!((indx_l[y] - coeff_[I]) %in% v_previous) == T){ 

                                        indx_l <- indx_l[-y]

                                }

                                y = y + 1

                        }

                        v_previous <- indx_l

                        ti = ti + 1

                }

                if (all(rtnl == vec) == T){

                        hmn_l <- append(hmn_l, length(indx_l))

                        for (t in 1:length(indx_l)){

                                rtnl_pos <- append(rtnl_pos, (indx_l[t] - coeff_[I] * (length(vec) - 1)))

                                rtnl_pos <- append(rtnl_pos, indx_l[t])

                        }

                        hmn_lf <- append(hmn_lf, hmn_l)

                        rtnl_pos_f <- append(rtnl_pos_f, rtnl_pos)

                        rtnl_pos_f <- append(rtnl_pos_f, "|")

                        rtnl_f <- append(rtnl_f, T)

                }else{

                        rtnl_f <- append(rtnl_f, F)

                        rtnl_pos_f <- append(rtnl_pos_f, "|")

                }

        }

        return(list(rtnl_f, rtnl_pos_f, hmn_lf))
        
}

#returns the number of row that contains vectors (multiple in a list), coeff and strt_l may vary 
#distinct is the value you are sure is not contained in the matrix 

#' closest_date
#'
#' return the closest dates from a vector compared to the input date
#' @param date_ is the input date
#' @param vec is a vector containing the dates to be compared to the input date
#' @param frmt is the format of the input date, (deault set to "snhdmy" (second, minute, hour, day, month, year), so all variable are taken in count),
#' if you only want to work with standard date for example change this variable to "dmy"
#' @param sep_ is the separator for the input date
#' @param sep_vec is the separator for the dates contained in vec
#' @param only_ is can be changed to "+" or "-" to repectively only return the higher dates and the lower dates (default set to "both")
#' @param head is the number of dates that will be returned (default set to NA so all dates in vec will be returned)
#' @export

closest_date <- function(vec, date_, frmt, sep_="/", sep_vec="/", only_="both", head=NA){

        date_ <- unlist(str_split(date_, sep_))

        lc <- c("s", "n", "h", "d", "m", "y")

        l_limit_max <- c(60, 60, 24, "check_l_nm", 12, 9999999)

        l_nm <- c(31, 28, 31, 30, 31, 30, 31, 31,
            30, 31, 30, 31)

        second_ <- NA

        min_ <- NA

        hour_ <- NA

        day_ <- NA

        month_ <- NA

        year_ <- NA

        l2 <- c()

        l <- c(second_, min_, hour_, day_, month_, year_)

        deb <- match(str_sub(frmt, 1, 1), lc)

        fin <- match(str_sub(frmt, nchar(frmt), nchar(frmt)), lc)

        df <- data.frame(matrix(NA, nrow=length(vec), ncol=(nchar(frmt) - 1)))

        df_bool <- data.frame(matrix(NA, nrow=length(vec), ncol=(nchar(frmt) - 1)))
       
        for (I in 1:(length(date_)-1)){

                cur <- as.numeric(date_[(length(date_) - (I - 1))])

                idx <- fin - (I - 1)

                val <- lc[idx]

                if (val == "m"){

                        m_ <- cur

                }

                if (l_limit_max[(idx-1)] == "check_l_nm"){

                        multiplicator <- l_nm[cur]

                }else{

                        multiplicator <- as.numeric(l_limit_max[idx-1])

                }
          
                to_diff <- cur * multiplicator + as.numeric(date_[(length(date_) - I)])
                
                for (i in 1:length(vec)){
                  
                        to_compare <- as.numeric(unlist(str_split(vec[i], sep_vec))[(length(date_) - (I-1))]) * multiplicator + as.numeric(unlist(str_split(vec[i], sep_vec))[(length(date_) - I)]) 
                        
                        df[i, I] <- abs(to_diff - to_compare)
                        
                        if ((to_compare - to_diff) < 0){
                          
                                df_bool[i, I] <- "-"

                        }else{
                          
                                df_bool[i, I] <- "+"

                        }

                }
                
        }

        if (is.na(head) == F){

                jsq <- head

        }else{

                jsq <- nrow(df)

        }

        if (only_ == "+"){ 

                df <- df[grep(TRUE, df_bool[, 1]=="+"), ]

        }

        if (only_ == "-"){ 

                df <- df[grep(TRUE, df_bool[, 1]=="-"), ]

        }

        fundamental_bool <- df_bool[, 1]
        
        rtnl <- c()
        
        for (I in 1:nrow(df)){
          
          dfb <- df
          
          df_boolb <- df_bool
          
          indx_l <- c()
          
          val_tp <- c(1:nrow(df))

          for (i in 1:ncol(df)){
          
            min_l <- which(min(dfb[, i]) == dfb[,i])
          
            val_tp <- val_tp[min_l]

            indx_l <- c()

            for (t in 1:length(min_l)){
             
              if (df_bool[min_l[t], i] != df_bool[min_l[t], 1]){
                
                indx_l <- append(indx_l, val_tp[t], after=0)
                
              }else{
                
                indx_l <- append(indx_l, val_tp[t])
                
              }
            
            }

            min_lb <- min_l

            dfb <- dfb[min_l, ]
            
          }
          
          rtnl <- append(rtnl, indx_l[1])
          
          df[indx_l[1], ] <- max(df[,1])
           
        }
        
  return(rtnl[1:jsq])
        
}

#' change_date
#'
#' Allow to add to a date second-minute-hour-day-month-year
#' @param date_ is the input date
#' @param sep_ is the date separator
#' @param day_ is the day to add (can be negative)
#' @param month_ is the month to add (can be negative)
#' @param year_ is the year to add (can be negative)
#' @param hour_ is the hour to add (can be negative)
#' @param min_ is the minute to add (can be negative)
#' @param second_ is the second to add (can be negative)
#' @param frmt is the format of the input date, (deault set to "snhdmy" (second, minute, hour, day, month, year), so all variable are taken in count),
#' if you only want to work with standard date for example change this variable to "dmy"
#' @export

change_date <- function(date_, sep_, day_  = NA, month_ = NA, 
                        year_ = NA, hour_ = NA, min_ = NA, 
                        second_ = NA, frmt="snhdmy"){
  
  frmt_l <- unlist(str_split(frmt, ""))
  
  date_ <- unlist(str_split(date_, sep_))
  
  l_nm <- c(31, 28, 31, 30, 31, 30, 31, 31,
            30, 31, 30, 31)
  
  l_nmc1 <- c(31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)
  
  l_nmc2 <- c(31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)
  
  l <- c(second_, min_, hour_, day_, month_, year_)
  
  lc <- c("s", "n", "h", "d", "m", "y")
  
  deb <- match(frmt_l[1], lc)
  
  l_limit_min <- c()
  
  l_limit_max <- c()
  
  l_limit_min_pre <- c(0, 0, 0, 1, 1, -999999)
  
  l_limit_max_pre <- c(60, 60, 24, "check_l_nm", 12, 9999999)
  
  for (i in deb:(deb+nchar(frmt) - 1)){
    
    l_limit_min <- append(l_limit_min, l_limit_min_pre[i])
    
    l_limit_max <- append(l_limit_max, l_limit_max_pre[i])
    
  }
  
  rtnl <- c() 
  
  year <- NA
  
  mois <- NA
  
  t = 1
  
  for (i in deb:(deb + nchar(frmt) - 1)){
    
    rtnl <- append(rtnl, l[i])
    
    if (lc[i] == "m"){
      
      mois <- as.numeric(date_[t])
      
    }
    
    if (lc[i] == "y"){
      
      year <- as.numeric(date_[t])
      
    }
    
    t = t + 1
    
  }
  
  if (is.na(year) == F){
    
    if (year %% 4 == 0){
      
      if (year %% 100 == 0){
        
        if (year %% 400 == 0){
          
          l_nm[2] <- 29
          
          l_nmc <- l_nmc2
          
        }else{
          
          l_nm[2] <- 28
          
          l_nmc <- l_nmc1
          
        }
        
      }else{
        
        l_nm[2] <- 29
        
        l_nmc <- l_nmc2
        
      }
      
    }else{
      
      l_nm[2] <- 28
      
      l_nmc <- l_nmc1
      
    }
    
  }else{
    
    l_nm[2] <- 28
    
    l_nmc <- l_nmc1
    
  }
  
  date_ <- as.numeric(date_)
  
  rtnl <- as.numeric(rtnl)
  
  for (i in 1:length(rtnl)){
    
    add_up <- abs(rtnl[i])
    
    rtnl[i] <- date_[i] + rtnl[i]
    
    if (rtnl[i] == l_limit_max[i] & str_sub(frmt, i, i) %in% c("h", "s", "n")){
      
      rtnl[i] <- 0
      
      if (i + 1 <= length(date_)){ date_[i+1] <- date_[i+1] + 1 }
      
    }
    
    if (l_limit_max[i] == "check_l_nm"){
      
      if (rtnl[i] < l_limit_min[i]){
        
        t = mois
        
        t2 = 1
        
        t3 = 1
        
        status <- 1
        
        all_b <- 0
        
        divider = l_nmc[12] * (t2 - 1) + (l_nmc[t] - l_nmc[mois - 1] * (status))  
        
        add_up <- abs(l_nmc[mois] - (l_nmc[mois] - rtnl[i]))
        
        reste <- add_up %% l_nm[mois]
        
        while (add_up %/% divider > 0){
          
          reste <- add_up %% l_nm[mois]
          
          if (t + 1 > (length(l_nmc) * t2)){
            
            if (status == 1){
              
              status2 = 1
              
              all_b <- l_nmc[t] - l_nmc[mois - 1] * status
              
              }else{
                
                status2=0
                
                t2 = t2 + 1
                
              }
              
              status <- 0
              
              t = 1
            
          }
          
          divider = l_nmc[12] * (t2 - 1) + (l_nmc[t] - l_nmc[mois - 1] * (status))  
          
          t = t + 1
          
          t3 = t3 + 1
          
        } 
        
        rtnl[i] <- l_nm[mois] - reste
        
        if (i + 1 <= length(date_)){

          if (t3 == 1){t3 = t3 + 1}
                    
          date_[i + 1] <- date_[i + 1] - (t3 - 1)
          
        }
        
      }
      
      if (rtnl[i] > l_nm[mois]){
        
        status <- 1
        
        status2 <- 0
        
        t = mois
        
        t2 = 1
        
        t3 = 1
        
        divider = l_nmc[12] * (t2 - 1) + (l_nmc[t] - l_nmc[mois - 1] * (status))  
        
        reste <- add_up %% l_nmc[t]
        
        all_b <- 0
        
        while (rtnl[i] %/% divider > 0){
          
          reste <- rtnl[i] %% divider
          
          if (t + 1 > (length(l_nmc) * t2)){
            
            if (status == 1){
              
              status2 = 1
              
              all_b <- l_nmc[t] - l_nmc[mois - 1] * status
              
            }else{
                
              status2=0
              
              t2 = t2 + 1
              
              }
            
            status <- 0
            
            t = 1
            
          }
          
          t = t + 1
          
          t3 = t3 + 1
          
          divider = l_nmc[12] * (t2 - 1) + (l_nmc[t] - l_nmc[mois - 1] * status) + status2 * all_b
            
        }
        
        rtnl[i] <- reste
        
        if (i + 1 <= length(date_)){
          
          if (t3 == 1){t3 = t3 + 1}
          
          date_[i + 1] <- date_[i + 1] + (t3 - 1)
          
        }
        
      }
      
    }else{
      
      if (rtnl[i] < l_limit_min[i]){
        
        t = 1
        
        add_up <- as.numeric(l_limit_max[i]) - (as.numeric(l_limit_max[i]) + rtnl[i])
        
        reste <- add_up %% (as.numeric(l_limit_max[i]) * t)
        
        while (add_up %/% (as.numeric(l_limit_max[i]) * t) > 0){
          
          reste <- add_up %% (as.numeric(l_limit_max[i]) * t)
          
          t = t + 1
          
        } 
        
        if (str_sub(frmt, i, i) == "m"){
          
          rtnl[i] <- as.numeric(l_limit_max[i]) - reste
          
        }else{
          
          if (reste == 0){
          
            rtnl[i] <- 0
            
            t = t - 1
            
          }else{
            
            rtnl[i] <- as.numeric(l_limit_max[i]) - reste 
          
          }
          
        }
        
        if (i + 1 <= length(date_)){
          
          date_[i + 1] <- date_[i + 1] - t
          
        }
        
      }
      
      if (rtnl[i] > as.numeric(l_limit_max[i])){
        
        t = 1
        
        reste <- rtnl[i] %% (as.numeric(l_limit_max[i]) * t)
        
        while (rtnl[i] %/% (as.numeric(l_limit_max[i]) * t) > 0){
          
          reste <- rtnl[i] %% (as.numeric(l_limit_max[i]) * t)
          
          t = t + 1
          
        } 
        
        if (str_sub(frmt, i, i) == "m"){
          
          rtnl[i] <- reste
          
        }else{
          
          rtnl[i] <- reste
          
        }
        
        if (i + 1 <= length(date_)){
          
          date_[i + 1] <- date_[i + 1] + (t-1)
          
        }
        
      }
      
    }
    
  }
  
  for (i in 1:length(rtnl)){
    
    if (nchar(rtnl[i]) == 1){
      
      rtnl[i] <- paste0("0", rtnl[i])
      
    }
    
  }
  
  rtnl2 <- ""
  
  for (i in 1:length(rtnl)){ rtnl2 <- paste0(rtnl2, "-", rtnl[i]) }  
  
  rtnl2 <- str_sub(rtnl2, 2, nchar(rtnl2))
  
  return(rtnl2)
  
}

#' pattern_gettr 
#'
#' Search for pattern(s) contained in a vector in another vector and return a list containing matched one (first index) and their position (second index) according to these rules:
#' First case: Search for patterns strictly, it means that the searched pattern(s) will be matched only if the patterns containded in the vector that is beeing explored by the function are present like this c("pattern_searched", "other", ..., "pattern_searched") and not as c("other_thing pattern_searched other_thing", "other", ..., "pattern_searched other_thing") 
#' Second case: It is the opposite to the first case, it means that if the pattern is partially present like in the first position and the last, it will be considered like a matched pattern
#' @param word_ is the vector containing the patterns
#' @param vct is the vector being searched for patterns
#' @param occ a vector containing the occurence of the pattern in word_ to be matched in the vector being searched, if the occurence is 2 for the nth pattern in word_ and only one occurence is found in vct so no pattern will be matched, put "forever" to no longer depend on the occurence for the associated pattern
#' @param strict a vector containing the "strict" condition for each nth vector in word_ ("strict" is the string to activate this option)
#' @param btwn is a vector containing the condition ("yes" to activate this option) meaning that if "yes", all elements between two matched patern in vct will be returned , so the patterns you enter in word_ have to be in the order you think it will appear in vct 
#' @param all_in_word is a value (default set to "yes", "no" to activate this option) that, if activated, won't authorized a previous matched pattern to be matched again
#' @param notatall is a string that you are sure is not present in vct
#' REGEX can also be used as pattern 
#' @export

pattern_gettr <- function(word_, vct, occ=c(1), strict, btwn, all_in_word="yes", notatall="###"){

  all_occ <- c()

  for (i in 1:length(word_)){ all_occ <- append(all_occ, 0) }

  if (length(btwn) < (length(occ) - 1)){

          to_app <- btwn[length(btwn)]

          for (i in length(btwn):(length(occ) - 2)){

                btwn <- append(btwn, to_app)

          }

  }

  if (length(strict) < length(occ)){

          to_app <- strict[length(strict)]

          for (i in length(strict):(length(occ) - 1)){

                strict <- append(strict, to_app)

          }

  }

  frst_occ <- c()

  occ_idx = 1

  get_ins = 0

  vct2 <- c()

  can_ins <- 0

  for (i in 1:length(vct)){

    to_compare = 0

    if (all_in_word == "yes"){

            if (strict[occ_idx] == "yes"){

                t = 1

                while (to_compare < 1 & t <= length(word_)){

                        if (nchar(word_[t]) == nchar(vct[i])){

                                v_bool <- str_detect(vct[i], word_[t])

                                to_compare = sum(v_bool)

                                if (to_compare > 0){indx <- t}

                        }

                        t = t + 1

                }

            }else{

                    v_bool <- str_detect(vct[i], word_)

                    to_compare =  sum(v_bool)

                    if (to_compare > 0){indx <- match(T, v_bool)}

            }

    }else{

       if (strict[occ_idx] == "yes"){

         t = 1

         while (t <= length(word_) & to_compare < 1){

           if (nchar(word_[t]) == nchar(vct[i])){

                v_bool <- str_detect(vct[i], word_[t])

                to_compare = sum(v_bool)

                if (to_compare > 0){indx <- t}

            }

            t = t + 1

         }

       }else{

        v_bool <- str_detect(vct[i], word_)

        to_compare =  sum(v_bool)

        if (to_compare > 0){indx <- match(T, v_bool)}

       }

    }

    if (to_compare > 0) {

      all_occ <- as.numeric(all_occ)

      all_occ[indx] = all_occ[indx] + 1

      all_occ <- as.character(all_occ)

      if (all_in_word == "no"){

              if (length(word_) >= 2){

                word_ <- word_[-indx]

              }else{

                word_[1] <- notatall

              }

      }

      if (all_occ[indx] == occ[indx] | occ[indx] == "forever"){

        can_ins <- 1
        
        frst_occ <- append(frst_occ, i)

        if (occ_idx <= length(btwn)){

          if (btwn[occ_idx] == "yes"){get_ins <- 1}else{get_ins <- 0}

        }else{

          get_ins <- 0

        }

        if ((occ_idx + 1) <= length(occ)){ occ_idx = occ_idx + 1 }

      }
      
    }

    if (get_ins == 1 | can_ins == 1){

        can_ins <- 0

        vct2 <- append(vct2, vct[i])

    }
    
  }
  
  return(list(frst_occ, vct2))
  
}

#' append_row
#'
#' @description Append the last row from dataframe to the another or same dataframe
#' @param df_in is the dataframe from which the row will append to another or the same  dataframe
#' @param df is the dataframe to which the row will append
#' @param hmn is how many time the last row will be appended
#' @param na_col is a vector containing the columns that won't append and will be replaced by another value (unique_do_not_know)
#' @param unique_do_not_know is the value of the non appending column in the appending row
#' @export

append_row <- function(df_in, df, hmn=1, na_col=c(), unique_do_not_know=NA){

        appender <- df_in[nrow(df), ]

        appender[na_col] <- unique_do_not_know

        for (i in 1:hmn){

                df <- rbind(df, appender)

        }

  return(df)

}

#' see_file
#'
#' Allow to get the filename or its extension
#' @param string_ is the input string
#' @param index_ext is the occurence of the dot that separates the filename and its extension
#' @param ext is a boolean that if set to TRUE, will return the file extension and if set to FALSE, will return filename
#' @export

see_file <- function(string_, index_ext=1, ext=T){

        file_as_vec <- unlist(str_split(string_, ""))

        index_point <- grep("\\.", file_as_vec)[index_ext]

        if (ext == T){

                rtnl <- paste(file_as_vec[index_point:length(file_as_vec)], collapse="")

                return(rtnl)

        }else{

                rtnl <- paste(file_as_vec[1:(index_point-1)], collapse="")

                return(rtnl)

        }

}

#' see_inside
#'
#' Return a list containing all the column of the files in the current directory with a chosen file extension and its associated file and sheet if xlsx. For example if i have 2 files "out.csv" with 2 columns and "out.xlsx" with 1 column for its first sheet and 2 for its second one, the return will look like this:
#' c(column_1, column_2, column_3, column_4, column_5, unique_separator, "1-2-out.csv", "3-3-sheet_1-out.xlsx", 4-5-sheet_2-out.xlsx)
#' @param pattern_ is a vector containin the file extension of the spreadsheets ("xlsx", "csv"...)
#' @param path_ is the path where are located the files
#' @param sep_ is a vector containing the separator for each csv type file in order following the operating system file order, if the vector does not match the number of the csv files found, it will assume the separator for the rest of the files is the same as the last csv file found. It means that if you know the separator is the same for all the csv type files, you just have to put the separator once in the vector.
#' @param unique_sep is a pattern that you know will never be in your input files
#' @param rec is a boolean allows to get files recursively if set to TRUE, defaults to TRUE 
#' If x is the return value, to see all the files name, position of the columns and possible sheet name associanted with, do the following: 
#' Examples: 
#' print(x[(grep(unique_sep, x)[1]+1):length(x)]) 
#' #If you just want to see the columns do the following: 
#' print(x[1:(grep(unique_sep, x) - 1)])
#' @export

see_inside <- function(pattern_, path_=".", sep_=c(","), unique_sep="#####", rec=F){

        x <- c()

        for (i in 1:length(pattern_)){ 

                x <- append(x, list.files(path=path_, pattern=pattern_[i], recursive=rec))

        }

        rtnl <- list()

        rtnl2 <- c()

        sep_idx = 1
        
        for (i in 1:length(x)){

                file_as_vec <- unlist(str_split(x[i], ""))

                index_point <- grep("\\.", file_as_vec)[1]

                ext <- paste(file_as_vec[index_point:length(file_as_vec)], collapse="")

                if (ext == ".xlsx"){

                        allname <- getSheetNames(x[i]) 

                        for (t in 1:length(allname)){
                          
                                df <- data.frame(read.xlsx(x[i], sheet=allname[t]))

                                rtnl <- append(rtnl, df)

                                rtnl2 <- append(rtnl2, paste((length(rtnl)+1) , (length(rtnl)+ncol(df)), x[i], allname[t], sep="-"))

                        }

                }else{
                  
                        df <- data.frame(read.table(x[i], fill=T, sep=sep_[sep_idx]))

                        rtnl <- append(rtnl, df)

                        rtnl2 <- append(rtnl2, paste((length(rtnl)+1) , (length(rtnl)+ncol(df)), x[i], sep="-"))

                        sep_idx = sep_idx + 1

                        if (sep_idx > length(sep_)){

                                sep_ <- append(sep_, sep_[length(sep_)])

                        }

                }

        }

        return(c(rtnl, unique_sep, rtnl2))

}

#' val_replacer
#' 
#' Allow to replace value from dataframe to another one.
#' @param df is the input dataframe
#' @param val_replaced is a vector of the value(s) to be replaced
#' @param val_replacor is the value that will replace val_replaced
#' @param df_rpt is the replacement matrix and has to be the same dimension as df. Only the indexes that are equal to TRUE will be authorized indexes for the values to be replaced in the input matrix
#' @export

val_replacer <- function(df, val_replaced, val_replacor=T, df_rpt=NA){
  
  for (i in 1:(ncol(df))){
    
      for (i2 in 1:length(val_replaced)){
        
        if (is.na(df_rpt) == F){
          
          vec_pos <- grep(val_replaced[i2], df[, i])
          
        }else{
          
          vec_pos <- grep(val_replaced[i2], df[, i])
          
          vec_pos2 <- grep(T, df_rpt[i])
          
          vec_pos <- grep(T, (vec_pos==vec_pos2))
          
        }
    
        df[vec_pos, i] <- val_replacor
    
      }
    
  }
  
  return(df)
  
}

#' see_idx
#'
#' Allow to find the indexes of the elements of the first vector in the second. If the element(s) is not found, the element returned at the same index will be "FALSE".
#' @param v1 is the first vector
#' @param v2 is the second vector
#' @param exclude_val is a value you know is not present in the 2 vectors
#' @param no_more is a boolean that, if set to TRUE, will remove all the first found value in the second vector after those has been found. It defaults to FALSE. 
#' @export

see_idx <- function(v1, v2, exclude_val="######", no_more=F){
 
  rtnl <- c()
 
  for (i in 1:length(v1)){

    if (length(grep(v1[i], v2)) > 0){

            r_idx <- match(v1[i], v2)

    }else{

            r_idx <- "F"

    }

    rtnl <- append(rtnl, r_idx)
    
    if (no_more == T){ v2[rtnl[length(rtnl)]] <- exclude_val }
    
  }
 
  return(rtnl)
 
}

#' date_sort
#'
#' Allow to ascendely or desendely sort dates in a vector.
#' @param vec is the vector containing the dates.
#' @param asc is a boolean variable, that if set to TRUE will sort the dates ascendely and descendely if set to FALSE
#' @param sep is the separator of the date strings ex: "11-12-1998" the separator is "-"
#' @export

date_sort <- function(vec, asc=F, sep="-"){
 
  vec2 <- str_split(vec, sep)
 
  s_vec <- c()
 
  for (i in 1:length(vec)){
    
    s_vec <- append(s_vec, prod(as.numeric(unlist(vec2[i]))))
    
  }
 
  if (asc==T){
 
    rtnl <- sort(s_vec, decreasing=F)
 
  }else{
    
    rtnl <- sort(s_vec, decreasing=T)
    
  }
 
  s_vec_idx <- c()
 
  for (i in 1:length(s_vec)){
    
    s_vec_idx <- append(s_vec_idx, grep(rtnl[i], s_vec))
    
  }
 
  return(vec[s_vec_idx])
 
}

#' file_rec2 
#' 
#' Allow to find the directories and the subdirectories with a specified end and start depth value from a path. This function might be more powerfull than file_rec because it uses a custom algorythm that does not nee to perform a full recursive search before tuning it to only find the directories with a good value of depth. Depth example: if i have dir/dir2/dir3, dir/dir2b/dir3b, i have a depth equal to 3
#' @param xmax is the depth value
#' @param xmin is the minimum value of depth
#' @param pathc is the reference path, from which depth value is equal to 1
#' @export

file_rec2 <- function(xmax, xmin=1, pathc="."){

        pathc2 <- pathc

        ref <- list.dirs(pathc, recursive=F)

        exclude_temp <- c()

        for (i in 1:xmax){ exclude_temp <- append(exclude_temp, c()) }

        exclude_f <- c("#")

        while (sum(exclude_f == ref) < length(ref)){

                if (length(grep("#", exclude_f)) > 0){

                        exclude_f <- c()

                }

                t = 1

                alf <- c("##")

                while (t <= xmax & length(alf) > 0){

                        alf <- list.dirs(pathc, recursive=F)

                        exclude_idx <- c()

                        if (length(exclude_temp) > 0){

                                for (i in 1:length(exclude_temp)){  

                                        in_t <- match(T, exclude_temp[i] == alf)

                                        if (is.na(in_t) == F){

                                                exclude_idx <- append(exclude_idx, in_t)

                                        }

                                } 

                        }

                        if (length(exclude_idx) > 0){ alf <- alf[-exclude_idx] }

                        if (length(alf) > 0 & t < xmax){

                                pathc <- alf[1]

                        }

                        t = t + 1

                }

                exclude_temp <- append(exclude_temp, pathc)

                ret_pathc <- pathc

                pathc <- paste(unlist(str_split(pathc, "/"))[1:str_count(pathc, "/")], collapse="/")

                if (pathc == pathc2){ exclude_f <- append(exclude_f, ret_pathc) }
                
        }

        ret <- grep(T, (str_count(exclude_temp, "/") < xmin))

        if (length(ret) > 0){

                return(exclude_temp[-ret])

        }else{

                return(exclude_temp)

        }

}

#' file_rec
#'
#' Allow to get all the files recursively from a path according to an end and start depth value. If you want to have an other version of this function that uses a more sophisticated algorythm (which can be faster), check file_rec2. Depth example: if i have dir/dir2/dir3, dir/dir2b/dir3b, i have a depth equal to 3
#' @param xmax is the end depth value
#' @param xmin is the start depth value
#' @param pathc is the reference path 
#' @export

file_rec <- function(xmax, xmin=1, pathc="."){

        vec <- list.dirs(pathc, recursive=T)

        rtnl <- c()

        for (i in 1:length(vec)){

                if (str_count(vec[i], "/") <= xmax & str_count(vec[i], "/") >= xmin){

                        rtnl <- append(rtnl, vec[i])

                }

        }

        return(rtnl)

}

#' get_rec 
#'
#' Allow to get the value of directorie depth from a path.
#' @param pathc is the reference path
#' example: if i have dir/dir2/dir3, dir/dir2b/dir3b, i have a depth equal to 3
#' @export

get_rec <- function(pathc="."){

        vec <- list.dirs(pathc, recursive=T)

        rtnl <- c()

        for (i in 1:length(vec)){

                rtnl <- append(rtnl, str_count(vec[i], "/"))

        }

        return(max(rtnl))

}

#' list_files
#' 
#' A list.files() based function addressing the need of listing the files with extension a or or extension b ...
#' @param pathc is the path, can be a vector of multiple path because list.files() supports it.
#' @param patternc is a vector containing all the exensions you want
#' @export

list_files <- function(patternc, pathc="."){

       rtnl <- c()

       for (i in 1:length(patternc)){

               rtnl <- append(rtnl, list.files(path=pathc, pattern=patternc[i]))

       }

       return(sort(rtnl))

}

#' match_n2
#'
#' Allow to get the indexes for the nth occurence of a value in a vector. Example: c(1, 2, 3, 1, 2), the first occurence of 1 and 2 is at index 1 and 2 respectively, but the second occurence is respectively at the 4th and 5th index.
#' @param vec is th einput vector
#' @param mc is a vector containing the values you want to get the index for the nth occurence in vec
#' @param n is a vector containing the occurences for each value in mc so if i have mc <- c(3, 27) and n <- c(1, 2), i want the first occurence for 3 and the second for 27 in vec. If the length of n is inferior of the length of mc, m will extend with its last value as new arguments. It means that if mc <- c(3, 27) but n <- c(1) so n will extend to c(1, 1), so we will get the first occurence of 3 and 27 in vec. 
#' @param wnb is a string you are sure is not in mc
#' @export

match_n2 <- function(vec, mc, n, wnb="#####"){

        vec2 <- vec

        for (I in 1:length(n)){

                vec <- vec2

                for (i in 1:n[I]){
                
                        vec[match(mc[I], vec)] <- wnb

                }

        }

        return(match(mc, vec2))

}

#' match_n
#'
#' Allow to get the indexes for the nth occurence of a value in a vector. Example: c(1, 2, 3, 1, 2), the first occurence of 1 and 2 is at index 1 and 2 respectively, but the second occurence is respectively at the 4th and 5th index.
#' @param vec is th input vector
#' @param mc is a vector containing the values you want to get the index for the nth occurence in vec
#' @param n is the value of the occurence
#' @param wnb is a string you are sure is not in mc
#' @export

match_n <- function(vec, mc, n=1, wnb="#####"){

        for (i in 1:n){
        
                vec[match(mc, vec)] <- wnb

        }

        return(match(mc, vec2))

}


#' ptrn_twkr
#'
#' Allow to modify the pattern length of element in a vector according to arguments. What is here defined as a pattern is something like this xx-xx-xx or xx/xx/xxx... So it is defined by the separator
#' @param inpt_l is the input vector
#' @param depth is the number (numeric) of separator it will keep as a result. To keep the number of separator of the element that has the minimum amount of separator do depth="min" and depth="max" (character) for the opposite. This value defaults to "max".
#' @param sep is the separator of the pattern, defaults to "-"
#' @param default_val is the default val that will be placed between the separator, defaults to "00" 
#' @param add_sep defaults to TRUE. If set to FALSE, it will remove the separator for the patterns that are included in the interval between the depth amount of separator and the actual number of separator of the element. 
#' @export
#'
#' @examples
#'library("stringr")
#' v <- c("2012-06-22", "2012-06-23", "2022-09-12", "2022")
#' ptrn_twkr(inpt_l=v, depth="max", sep="-", default_val="00", add_sep=TRUE)

ptrn_twkr <- function(inpt_l, depth="max", sep="-", 
                      default_val="0", add_sep=T){
  
  ln <- length(inpt_l)
  
  if (depth == "min"){
    
    pre_val <- str_count(inpt_l[1], sep)
    
    for (i in 2:ln){
      
      if (str_count(inpt_l[i], sep) < pre_val){
        
        pre_val <- str_count(inpt_l[i], sep)
        
      }
      
    }
    
    depth <- pre_val
    
  }

  if (depth == "max"){
    
    pre_val <- str_count(inpt_l[1], sep)
    
    for (i in 2:ln){
      
      if (str_count(inpt_l[i], sep) > pre_val){
        
        pre_val <- str_count(inpt_l[i], sep)
        
      }
      
    }
    
    depth <- pre_val
    
  }

  for (I in 1:ln){
   
    hmn <- str_count(inpt_l[I], "-")
    
    if (hmn < depth){
     
      inpt_l[I] <- paste0(inpt_l[I], sep, default_val)

      diff <- depth - hmn - 1

      if (diff > 0){
      
                if (add_sep == T){
                  
                  for (i in 1:diff){
                  
                    inpt_l[I] <- paste0(inpt_l[I], sep, default_val)
                  
                  }
                
                }else{
                  
                  for (i in 1:diff){
                    
                    inpt_l[I] <- paste0(inpt_l[I], default_val)
                    
                  }
                  
                }

     }
    
    }else if(depth < hmn){

        if (add_sep == T){

                inpt_l[I] <- paste(unlist(strsplit(inpt_l[I], split=sep))[1:(depth+1)], collapse=sep)

        }else{

                inpt_l[I] <- paste(unlist(strsplit(inpt_l[I], split=sep))[1:(depth+1)], collapse="")
       
        }

    }

  }
    
  return(inpt_l)
  
}

#' extrm_dates
#' 
#' Allow to find the minimum or the maximum of a date in a vector. The format of dates is Year/Month/Day.
#' @param inpt_l is the input vector
#' @param extrm is either "min" or "max", defaults to "min"
#' @param sep is the separator of the dates, defaults to "-"
#' @export

extrm_dates <- function(inpt_l, extrm="min", sep="-"){
  
  rtn <- ""
  
  for (I in 1:length(unlist(strsplit(inpt_l[1], sep)))){
    
    lnd <- length(inpt_l)
    
    if (lnd == 1){ return(inpt_l[1]) }
    
    cur_dte_l <- c()
    
    cur_val <- unlist(strsplit(inpt_l[1], sep))[I]
    
    if (extrm == "min"){
      
      for (i in 2:lnd){
        
        if(unlist(strsplit(inpt_l[i], sep))[I] < cur_val){
          
          cur_val <- unlist(strsplit(inpt_l[i], sep))[I]
          
        }else{
          
          inpt_l[i] <- "#"
          
        }
        
      }
      
    }else{
      
      for (i in 2:lnd){
        
        if(unlist(strsplit(inpt_l[i], sep))[I] > cur_val){
          
          cur_val <- unlist(strsplit(inpt_l[i], sep))[I]
          
        }else{
          
          inpt_l[i] <- "#"
          
        }
        
      }
      
    }
    
  if (rtn == ""){
    
    rtn <- cur_val
    
  }else{
    
    rtn <- paste0(rtn, sep, cur_val)
    
  }
    
    inpt_l <- inpt_l[!(inpt_l=="#")]
    
  }
  
  return(rtn)
  
}

#' fillr
#' 
#' Allow to fill a vector by the last element n times
#' @param inpt_v is the input vector
#' @param ptrn_fill is the pattern used to detect where the function has to fill the vector by the last element n times. It defaults to "...\\d" where "\\d" is the regex for an int value. So this paramater has to have "\\d" which designates n.
#' @export
#' @examples
#' fillr(c("a", "b", "...3", "c"))

fillr <- function(inpt_v, ptrn_fill="...\\d"){
  
  ptrn <- grep(ptrn_fill, inpt_v)

  while (length(ptrn) > 0){
   
    ptrn <- grep(ptrn_fill, inpt_v)

    idx <- ptrn[1] 
    
    untl <- as.numeric(c(unlist(strsplit(inpt_v[idx], split="\\.")))[4]) - 1
   
    pre_val <- inpt_v[(idx - 1)]

    inpt_v[idx] <- pre_val

    if (untl > 0){
    
      for (i in 1:untl){
        
        inpt_v <- append(inpt_v, pre_val, idx)
        
      }
      
    }

  ptrn <- grep(ptrn_fill, inpt_v)
    
  }
  
  return(inpt_v)
  
}

#' ptrn_switchr
#' 
#' Allow to switch, copy pattern for each element in a vector. Here a pattern is the values that are separated by a same separator. Example: "xx-xxx-xx" or "xx/xx/xxxx". The xx like values can be swicthed or copied from whatever index to whatever index. Here, the index is like this 1-2-3 etcetera, it is relative of the separator. 
#' @param inpt_l is the input vector
#' @param f_idx_l is a vector containing the indexes of the pattern you want to be altered.
#' @param t_idx_l is a vector containing the indexes to which the indexes in f_idx_l are related.
#' @param sep is the separator, defaults to "-"
#' @param default_val is the default value , if not set to NA, of the pattern at the indexes in f_idx_l. If it is not set to NA, you do not need to fill t_idx_l because this is the vector containing the indexes of the patterns that will be set as new values relatively to the indexes in f_idx_l. Defaults to NA.
#' @export
#' @examples 
#' ptrn_switchr(inpt_l=c("2022-01-11", "2022-01-14", "2022-01-21", 
#' "2022-01-01"), f_idx_l=c(1, 2, 3), t_idx_l=c(3, 2, 1))
#' ptrn_switchr(inpt_l=c("2022-01-11", "2022-01-14", "2022-01-21", 
#' "2022-01-01"), f_idx_l=c(1), default_val="ee")

ptrn_switchr <- function(inpt_l, f_idx_l=c(), t_idx_l=c(), sep="-", default_val=NA){

        if (is.na(default_val) == T){

                for (I in 1:length(inpt_l)){

                        pre_val <- unlist(strsplit(inpt_l[I], split=sep))

                        pre_val2 <- pre_val

                        for (i in 1:length(f_idx_l)){

                               pre_val2[f_idx_l[i]] <- pre_val[t_idx_l[i]]

                        }

                        inpt_l[I] <- paste(pre_val2, collapse=sep)

                }

        }else{

                for (I in 1:length(inpt_l)){

                        pre_val <- unlist(strsplit(inpt_l[I], split=sep))

                        for (i in 1:length(f_idx_l)){

                               pre_val[f_idx_l[i]] <- default_val

                        }

                        inpt_l[I] <- paste(pre_val, collapse=sep)

                }

        }

        return(inpt_l)

}

#' v_to_df
#'
#' Allow to convert a vector to a dataframe according to a separator.
#' @param inpt_v is the input vector
#' @param sep is the separator used to seprate the columns
#' @export
#' @examples 
#' library("stringr")
#' v <- c("aa-yy-uu", "zz-gg-hhh", "zz-gg-hhh", "zz-gg-hhh")
#' v_to_df(inpt_v=v, sep="-")

v_to_df <- function(inpt_v, sep="-"){

        n_col <- str_count(inpt_v[1], sep) + 1

        pre_l <- strsplit(inpt_v, sep)

        pre_v <- c(unlist(pre_l[1])[1])

        for (i in 2:length(inpt_v)){

                pre_v <- c(pre_v, unlist(pre_l[i])[1])

        }

        rtn_df <- data.frame(pre_v)

        for (I in 2:n_col){

                pre_v <- c(unlist(pre_l[1])[I])

                for (i in 2:length(inpt_v)){

                        pre_v <- c(pre_v, unlist(pre_l[i])[I])

                }

                rtn_df <- cbind(rtn_df, pre_v)

        }

        return(rtn_df)
}

#' globe
#'
#' Allow to calculate the distances between a set of geographical points and another established geographical point. If the altitude is not filled, so the result returned won't take in count the altitude.
#' @param lat_f is the latitude of the established geographical point
#' @param long_f is the longitude of the established geographical point
#' @param alt_f is the altitude of the established geographical point, defaults to NA
#' @param lat_n is a vector containing the latitude of the set of points
#' @param long_n is a vector containing the longitude of the set of points
#' @param alt_n is a vector containing the altitude of the set of points, defaults to NA
#' @export
#' @examples
#' globe(lat_f=23, long_f=112, alt_f=NA, lat_n=c(2, 82), long_n=c(165, -55), alt_n=NA) 

globe <- function(lat_f, long_f, alt_f=NA, lat_n, long_n, alt_n=NA){

        rtn_l <- c()

        for (i in 1:length(lat_n)){

               sin_comp <- abs(sin(pi * ((lat_n[i] + 90) / 180)))

               if (abs(long_f - long_n[i]) != 0){

                       delta_long <- (40075 / (360 / abs(long_f - long_n[i]))) * sin_comp

               }else{

                       delat_long <- 0

               }

               if (abs(lat_f - lat_n[i]) != 0){

                        delta_lat <- 20037.5 / (180 / abs(lat_f - lat_n[i]))

               }else{

                        delta_lat <- 0

               }

               delta_f <- (delta_lat ** 2 + delta_long ** 2) ** 0.5

               if (is.na(alt_n[i]) == F & is.na(alt_f) == F){

                        delta_f <- ((alt_n[i] - alt_f) ** 2 + delta_f ** 2) ** 0.5

               }

               rtn_l <- append(rtn_l, delta_f, after=length(rtn_l))

        }

        return(rtn_l)

}

#' geo_min
#' 
#' Return a dataframe containing the nearest geographical points (row) according to established geographical points (column).
#' @param inpt_df is the input dataframe of the set of geographical points to be classified, its firts column is for latitude, the second for the longitude and the third, if exists, is for the altitude. Each point is one row.
#' @param established_df is the dataframe containing the coordiantes of the established geographical points
#' @export
#' @examples
#'in_ <- data.frame(c(11, 33, 55), c(113, -143, 167))
#'
#'in2_ <- data.frame(c(12, 55), c(115, 165))
#'
#'print(geo_min(inpt_df=in_, established_df=in2_))
#'
#'in_ <- data.frame(c(51, 23, 55), c(113, -143, 167), c(6, 5, 1))
#'
#'in2_ <- data.frame(c(12, 55), c(115, 165), c(2, 5))
#'
#'geo_min(inpt_df=in_, established_df=in2_)

geo_min <- function(inpt_df, established_df){

       globe <- function(lat_f, long_f, alt_f=NA, lat_n, long_n, alt_n=NA){

               sin_comp <- abs(sin(pi * ((lat_n + 90) / 180)))

               if (abs(long_f - long_n) != 0){

                       delta_long <- (40075 / (360 / abs(long_f - long_n))) * sin_comp

               }else{

                       delat_long <- 0

               }

               if (abs(lat_f - lat_n) != 0){

                        delta_lat <- 20037.5 / (180 / abs(lat_f - lat_n))

               }else{

                        delta_lat <- 0

               }

               delta_f <- (delta_lat ** 2 + delta_long ** 2) ** 0.5

               if (is.na(alt_n) == F & is.na(alt_f) == F){

                        delta_f <- ((alt_n - alt_f) ** 2 + delta_f ** 2) ** 0.5

               }

               return(delta_f)

       }

      flag_delta_l <- c()

      rtn_df <- data.frame(matrix(nrow=nrow(inpt_df), ncol=nrow(established_df)))

      if (ncol(inpt_df) == 3){

              for (i in 1:nrow(inpt_df)){

                      flag_delta_l <- c(flag_delta_l, globe(lat_f=established_df[1, 1], long_f=established_df[1, 2], alt_f=established_df[1, 3], lat_n=inpt_df[i, 1], long_n=inpt_df[i, 2], alt_n=inpt_df[i, 3]))

              }

              rtn_df[,1] <- flag_delta_l

              if (nrow(established_df) > 1){

                      for (I in 2:nrow(established_df)){

                               for (i in 1:nrow(inpt_df)){

                                        idx <- which(is.na(rtn_df[i,]) == F)

                                        res <- globe(lat_f=established_df[I, 1], long_f=established_df[I, 2], alt_f=established_df[I, 3], lat_n=inpt_df[i, 1], long_n=inpt_df[i, 2], alt_n=inpt_df[i, 3])

                                        if (rtn_df[i, 1:(I-1)][idx] > res){

                                               rtn_df[i, I] <- rtn_df[i, idx] 

                                               rtn_df[i, idx] <- NA 

                                        }

                                }

                        }

              }

      }else{

              for (i in 1:nrow(inpt_df)){

                      flag_delta_l <- c(flag_delta_l, globe(lat_f=established_df[1, 1], long_f=established_df[1, 2], lat_n=inpt_df[i, 1], long_n=inpt_df[i, 2]))

              }

              rtn_df[,1] <- flag_delta_l

              if (nrow(established_df) > 1){

                      for (I in 2:nrow(established_df)){

                               for (i in 1:nrow(inpt_df)){

                                        idx <- which(is.na(rtn_df[i,]) == F)

                                        res <- globe(lat_f=established_df[I, 1], long_f=established_df[I, 2], lat_n=inpt_df[i, 1], long_n=inpt_df[i, 2])

                                        if (rtn_df[i, 1:(I-1)][idx] > res){

                                               rtn_df[i, I] <- res 

                                               rtn_df[i, idx] <- NA 

                                        }

                               }

                        }

              }

      }

      return(rtn_df)

}

#' nestr_df2
#'
#' Allow to write a special value (1a) in the cells of a dataframe (1b) that correspond (row and column) to whose of another dataframe (2b) that return another special value (2a). The cells whose coordinates do not match the coordinates of the dataframe (2b), another special value can be written (3a) if not set to NA. 
#' @param inptf_df is the input dataframe (1b)
#' @param rtn_pos is the special value (1a)
#' @param rtn_neg is the special value (3a) 
#' @param nestr_df is the dataframe (2b)
#' @param yes_val is the special value (2a) 
#' @export
#' @examples
#' nestr_df2(inptf_df=data.frame(c(1, 2, 1), c(1, 5, 7)), rtn_pos="yes", 
#' rtn_neg="no", nestr_df=data.frame(c(TRUE, FALSE, TRUE), c(FALSE, FALSE, TRUE)), yes_val=TRUE) 

nestr_df2 <- function(inptf_df, rtn_pos, rtn_neg=NA, nestr_df, yes_val=T){

        if (is.na(rtn_neg) == T){

                for (I in 1:ncol(nestr_df)){

                        for (i in 1:nrow(nestr_df)){

                                if (nestr_df[i, I] == yes_val){

                                        inptf_df[i, I] <- rtn_pos

                                }

                        }

                }

        }else{

                for (I in 1:ncol(nestr_df)){

                        for (i in 1:nrow(nestr_df)){

                                if (nestr_df[i, I] == yes_val){

                                        inptf_df[i, I] <- rtn_pos

                                }else{

                                        inptf_df[i, I] <- rtn_neg

                                }

                        }

                }

        }

    return(inptf_df)

}

#' nestr_df1
#'
#' Allow to write a value (1a) to a dataframe (1b) to its cells that have the same coordinates (row and column) than the cells whose value is equal to a another special value (2a), from another another dataframe (2b). The value (1a) depends of the cell  value coordinates of the third dataframe (3b). If a cell coordinates (1c) of the first dataframe (1b) do not correspond to the coordinates of a good returning cell value (2a) from the dataframe (2b), so this cell (1c) can have its value changed to the same cell coordinates value (3a) of a third dataframe (4b), if (4b) is not det to NA.
#' @param inptf_df is the input dataframe (1b)
#' @param inptt_pos_df is the dataframe (2b) that corresponds to the (1a) values
#' @param inpt_neg_df is the dataframe (4b) that has the (3a) values, defaults to NA
#' @param nestr_df is the dataframe (2b) that has the special value (2a)
#' @param yes_val is the special value (2a)
#' @export
#' @examples
#' nestr_df1(inptf_df=data.frame(c(1, 2, 1), c(1, 5, 7)), 
#' inptt_pos_df=data.frame(c(4, 4, 3), c(2, 1, 2)), 
#' inptt_neg_df=data.frame(c(44, 44, 33), c(12, 12, 12)), 
#' nestr_df=data.frame(c(TRUE, FALSE, TRUE), c(FALSE, FALSE, TRUE)), yes_val=TRUE) 

nestr_df1 <- function(inptf_df, inptt_pos_df, nestr_df, yes_val=T, inptt_neg_df=NA){

        if (all(is.na(inptt_neg_df)) == T){

                for (I in 1:ncol(nestr_df)){

                        for (i in 1:nrow(nestr_df)){

                                if (nestr_df[i, I] == yes_val){

                                        inptf_df[i, I] <- inptt_df[i, I]

                                }

                        }

                }

        }else{

                for (I in 1:ncol(nestr_df)){

                        for (i in 1:nrow(nestr_df)){

                                if (nestr_df[i, I] == yes_val){

                                        inptf_df[i, I] <- inptt_pos_df[i, I]

                                }else{

                                        inptf_df[i, I] <- inptt_neg_df[i, I]

                                }

                        }

                }

        }

    return(inptf_df)

}

#' groupr_df
#' 
#' Allow to create groups from a dataframe. Indeed, you can create conditions that lead to a flag value for each cell of the input dataframeaccording to the cell value. This function is based on see_df and nestr_df2 functions.
#' @param inpt_df is the input dataframe
#' @param condition_lst is a list containing all the condition as a vector for each group
#' @param val_lst is a list containing all the values associated with condition_lst as a vector for each group
#' @param conjunction_lst is a list containing all the conjunctions associated with condition_lst and val_lst as a vector for each group
#' @param rtn_val_pos is a vector containing all the group flag value like this ex: c("flag1", "flag2", "flag3") 
#' @export
#' @examples interactive()
#'df1 <- data.frame(c(1, 2, 1), c(45, 22, 88), c(44, 88, 33))
#'
#'val_lst <- list(list(c(1), c(1)), list(c(2)), list(c(44)))
#'
#'condition_lst <- list(c(">", "<"), c("%%"), c("=="))
#'
#'conjunction_lst <- list(c("|"), c(), c())
#'
#'rtn_val_pos <- c("+", "+", "+")
#'
#'groupr_df(inpt_df=df1, val_lst=val_lst, condition_lst=condition_lst, 
#'conjunction_lst=conjunction_lst, rtn_val_pos=rtn_val_pos)

groupr_df <- function(inpt_df, condition_lst, val_lst, conjunction_lst, rtn_val_pos=c()){
 
        nestr_df2 <- function(inptf_df, rtn_pos, rtn_neg=NA, nestr_df, yes_val=T){

                if (is.na(rtn_neg) == T){

                        for (I in 1:ncol(nestr_df)){

                                for (i in 1:nrow(nestr_df)){

                                        if (nestr_df[i, I] == yes_val){

                                                inptf_df[i, I] <- rtn_pos

                                        }

                                }

                        }

                }else{

                        for (I in 1:ncol(nestr_df)){

                                for (i in 1:nrow(nestr_df)){

                                        if (nestr_df[i, I] == yes_val){

                                                inptf_df[i, I] <- rtn_pos

                                        }else{

                                                inptf_df[i, I] <- rtn_neg

                                        }

                                }

                        }

                }

            return(inptf_df)

        }
 
        see_df <- function(df, condition_l, val_l, conjunction_l=c(), rt_val=T, f_val=F){

                if (length(condition_l) > 1 & length(conjunction_l) < (length(condition_l) - 1)){

                        for (i in (length(conjunction_l)+1):length(condiction_l)){

                                conjunction_l <- append(conjunction_l, conjunction_l[length(conjunction_l)])

                        }

                }

                df_rtnl <- data.frame(matrix(f_val, ncol=ncol(df), nrow=nrow(df)))

                all_op <- c("==", ">", "<", "!=", "%%")

                for (I in 1:ncol(df)){

                        for (i in 1:nrow(df)){

                                checked_l <- c()

                                previous = 1

                                for (t in 1:length(condition_l)){

                                        already <- 0

                                        if (condition_l[t] == "==" & already == 0){

                                                if (df[i, I] %in% unlist(val_l[t])){

                                                        checked_l <- append(checked_l, T)

                                                        if (length(condition_l) > 1 & t > 1){

                                                                bfr <- conjunction_l[previous:t]

                                                                if (t == length(condition_l)){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }else if (conjunction_l[t] == "|"){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }

                                                        }else if (length(condition_l) == 1){

                                                                df_rtnl[i, I] <- rt_val

                                                        }else {

                                                                if (conjunction_l[1] == "|"){

                                                                        df_rtnl[i, I] <- rt_val

                                                                        checked_l <- c()

                                                                }

                                                        }

                                                }

                                                if (t <= length(conjunction_l)){ 

                                                        if (conjunction_l[t] == "|"){

                                                                checked_l <- c()

                                                                previous = t + 1 

                                                        }

                                                }

                                        }

                                        if (condition_l[t] == ">" & already == 0){

                                                if (all(df[i, I] > unlist(val_l[t])) == T){

                                                        checked_l <- append(checked_l, T)

                                                        if (length(condition_l) > 1 & t > 1){

                                                                bfr <- conjunction_l[previous:t]

                                                                if (t == length(condition_l)){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }else if (conjunction_l[t] == "|"){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }

                                                        }else if (length(condition_l) == 1){

                                                                df_rtnl[i, I] <- rt_val

                                                        }else {

                                                                if (conjunction_l[1] == "|"){

                                                                        df_rtnl[i, I] <- rt_val

                                                                        checked_l <- c()

                                                                }

                                                        }

                                                }

                                                if (t <= length(conjunction_l)){ 

                                                        if (conjunction_l[t] == "|"){

                                                                checked_l <- c()

                                                                previous = t + 1 

                                                        }

                                                }

                                        }

                                        if (condition_l[t] == "<" & already == 0){

                                                if (all(df[i, I] < unlist(val_l[t]))){

                                                        checked_l <- append(checked_l, T)

                                                        if (length(condition_l) > 1 & t > 1){

                                                                bfr <- conjunction_l[previous:t]

                                                                if (t == length(condition_l)){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }else if (conjunction_l[t] == "|"){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }

                                                        }else if (length(condition_l) == 1){

                                                                df_rtnl[i, I] <- rt_val

                                                        }else {

                                                                if (conjunction_l[1] == "|"){

                                                                        df_rtnl[i, I] <- rt_val

                                                                        checked_l <- c()

                                                                }

                                                        }

                                                }

                                                if (t <= length(conjunction_l)){ 

                                                        if (conjunction_l[t] == "|"){

                                                                checked_l <- c()

                                                                previous = t + 1 

                                                        }

                                                }

                                        }

                                        if (condition_l[t] == "!=" & already == 0){

                                                if (!(df[i, I] %in% unlist(val_l[t])) == T){

                                                        checked_l <- append(checked_l, T)

                                                        if (length(condition_l) > 1 & t > 1){

                                                                bfr <- conjunction_l[previous:t]

                                                                if (t == length(condition_l)){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }else if (conjunction_l[t] == "|"){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }

                                                        }else if (length(condition_l) == 1){

                                                                df_rtnl[i, I] <- rt_val

                                                        }else {

                                                                if (conjunction_l[1] == "|"){

                                                                        df_rtnl[i, I] <- rt_val

                                                                        checked_l <- c()

                                                                }

                                                        }

                                                }

                                                if (t <= length(conjunction_l)){ 

                                                        if (conjunction_l[t] == "|"){

                                                                checked_l <- c()

                                                                previous = t + 1 

                                                        }

                                                }

                                        }

                                        if (condition_l[t] == "%%" & already == 0){

                                                if (sum(df[i, I] %% unlist(val_l[t])) == 0){

                                                        checked_l <- append(checked_l, T)

                                                        if (length(condition_l) > 1 & t > 1){

                                                                bfr <- conjunction_l[previous:t]

                                                                if (t == length(condition_l)){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }else if (conjunction_l[t] == "|"){

                                                                        if (length(checked_l) == length(bfr)){

                                                                                already <- 1

                                                                                df_rtnl[i, I] <- rt_val

                                                                        }

                                                                }

                                                        }else if (length(condition_l) == 1){

                                                                df_rtnl[i, I] <- rt_val

                                                        }else {

                                                                if (conjunction_l[1] == "|"){

                                                                        df_rtnl[i, I] <- rt_val

                                                                        checked_l <- c()

                                                                }

                                                        }

                                                }

                                                if (t <= length(conjunction_l)){ 

                                                        if (conjunction_l[t] == "|"){

                                                                checked_l <- c()

                                                                previous = t + 1 

                                                        }

                                                }

                                        }

                                }
                                
                        }

                }

          return(df_rtnl)

        }
              
        rtn_df <- data.frame(matrix(nrow=nrow(inpt_df), ncol=ncol(inpt_df)))

        for (I in 1:length(condition_lst)){

                pre_df <- see_df(df=inpt_df, condition_l=unlist(condition_lst[I]), val_l=unlist(val_lst[I]), conjunction_l=unlist(conjunction_lst[I])) 

                rtn_df <- nestr_df2(inptf_df=rtn_df, nestr_df=pre_df, rtn_pos=rtn_val_pos[I], rtn_neg=NA)  

        }

        return(rtn_df)

}

#' occu
#'
#' Allow to see the occurence of each variable in a vector. Returns a datafame with, as the first column, the all the unique variable of the vector and , in he second column, their occurence respectively.
#' @param inpt_v the input dataframe

occu <- function(inpt_v){

    presence <- which(inpt_v == "")

    if (length(presence) > 0){ inpt_v <- inpt_v[-presence] }

    occu_v <- c()
    
    modal_v <- c()

    for (el in inpt_v){
      
      if (length(grep(el, modal_v)) == 1){
        
        idx <- which(modal_v == el)
        
        occu_v[idx] = occu_v[idx] + 1
        
      }else{
        
        occu_v <- append(x=occu_v, values=1, after=length(occu_v))
        
        modal_v <- append(x=modal_v, values=el, after=length(occu_v))
       
      }
    
    }

    return(data.frame("var"=modal_v, "occurence"=occu_v))
 
}


#' all_stat
#'
#' Allow to see all the main statistics indicators (mean, median, variance, standard deviation, sum, max, min, quantile) of variables in a dataframe by the modality of a variable in a column of the input datarame. In addition to that, you can get the occurence of other qualitative variables by your chosen qualitative variable, you have just to precise it in the vector "stat_var" where all the statistics indicators are given with "occu-var_you_want/".
#' @param inpt_v is the modalities of the variables 
#' @param var_add is the variables you want to get the stats from
#' @param stat_var is the stats indicators you want
#' @param inpt_df is the input dataframe
#' @examples
#' df <- data.frame("mod"=c("first", "seco", "seco", "first", "first", "third", "first"), 
#'                 "var1"=c(11, 22, 21, 22, 22, 11, 9), 
#'                "var2"=c("d", "d", "z", "z", "z", "d", "z"), 
#'                "var3"=c(45, 44, 43, 46, 45, 45, 42),
#'               "var4"=c("A", "A", "A", "A", "B", "C", "C"))
#'
#' all_stat(inpt_v=c("first", "seco"), var_add = c("var1", "var2", "var3", "var4"), 
#'  stat_var=c("sum", "mean", "median", "sd", "occu-var2/", "occu-var4/", "variance", "quantile-0.75/"), 
#'  inpt_df=df)


all_stat <- function(inpt_v, var_add=c(), stat_var=c(), inpt_df){
 
  presence <- which(inpt_v == "")
    
  if (length(presence) > 0){ inpt_v <- inpt_v[-presence] }
  
  fillr <- function(inpt_v, ptrn_fill="...\\d"){
    
    ptrn <- grep(ptrn_fill, inpt_v)
    
    while (length(ptrn) > 0){
      
      ptrn <- grep(ptrn_fill, inpt_v)
      
      idx <- ptrn[1]
      
      untl <- as.numeric(c(unlist(strsplit(inpt_v[idx], split="\\.")))[4]) - 1
      
      pre_val <- inpt_v[(idx - 1)]
      
      inpt_v[idx] <- pre_val
      
      if (untl > 0){
        
        for (i in 1:untl){
          
          inpt_v <- append(inpt_v, pre_val, idx)
          
        }
        
      }
      
      ptrn <- grep(ptrn_fill, inpt_v)
      
    }
    
    return(inpt_v)
    
  }
 
  pre_var <- grep("occu-", stat_var)

  col_ns <- colnames(inpt_df)

  if (length(pre_var) > 0){ 

          u_val <- c()

          mod_idx <- c()

          idx_col <- c()

          for (idx in pre_var){

                  col_ <- unlist(strsplit(stat_var[idx], split=""))

                  end_beg <- str_locate(stat_var[idx], "-(.*?)/")

                  col_2 <- paste(col_[(end_beg[1]+1):(end_beg[2]-1)], collapse="")

                  col_ <- which(col_ns == col_2)[1] 

                  un_v <- unique(df[, col_])

                  for (i in 1:length(un_v)){ idx_col <- c(idx_col, col_) }

                  pre_occu <- paste(col_2, un_v, sep="-")

                  u_val <- c(u_val, un_v)

                  idx_vd <- which(var_add == col_2)

                  var_add[idx_vd] <- pre_occu[1] 

                  var_add <- append(x=var_add, values=pre_occu[2:length(pre_occu)], after=idx_vd)

                  mod_idx <- c(mod_idx, c(idx_vd:(idx_vd+length(un_v)-1)))

          }

  }

  extend <- paste("...", as.character(length(var_add) - 1))

  if (length(var_add) > 0){
  
    list_stat <- list()
    
    modal_v <- c()
    
    var_vector <- c()
    
    for (el in inpt_v){
      
      modal_v <- c(modal_v, el, fillr(inpt_v=c("", extend)))
      
      var_vector <- c(var_vector, "", var_add)
      
    }

    rtn_df <- data.frame(modal_v, var_vector)

    pre_length_var_add <- length(var_add)

    if (length(mod_idx) > 0){

        vec_cur <- c(matrix(nrow=length(var_vector), ncol=1, data=""))

        for (vr in 1:length(inpt_v)){

            for (idx in 1:length(mod_idx)){

                cur_col <- df[, idx_col[idx]]

                vec_cur[length(var_add) * (vr - 1) + mod_idx[idx] + vr] <- sum(cur_col[df[, 1] == inpt_v[vr]] == u_val[idx])

            }

        }

        stat_var <- stat_var[-grep("occu-", stat_var)]

        rtn_df <- cbind(rtn_df, "occu"=vec_cur)

        var_add <- var_add[-mod_idx]

    }

    mod_idx <- c(1:pre_length_var_add)[-mod_idx]

    for (st in stat_var){

        vec_cur <- c(matrix(nrow=length(var_vector), ncol=1, data=""))

        if (st == "max"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- max(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

            rtn_df <- cbind(rtn_df, "max"=vec_cur)

        }

        if (st == "min"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- min(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

            rtn_df <- cbind(rtn_df, "min"=vec_cur)

        }

        if (st == "variance"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- var(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

            rtn_df <- cbind(rtn_df, "variance"=vec_cur)

        }
        
        if (st == "sd"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- sd(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

            rtn_df <- cbind(rtn_df, "standard_devaition"=vec_cur)

        }
        
        if (st == "sum"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- sum(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

            rtn_df <- cbind(rtn_df, "sum"=vec_cur)

        }

        if (st == "median"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- median(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

            rtn_df <- cbind(rtn_df, "med"=vec_cur)

        }

        if (length(grep("quantile", st)) > 0){

            idx_v <- str_locate(st, "-(.*?)/")

            nb_quant <- as.numeric(paste(unlist(strsplit(x=st, split=""))[(idx_v[1]+1):(idx_v[2]-1)], collapse=""))

            print(nb_quant)

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- quantile(cur_col[df[,1] == inpt_v[vr]], 
                    probs=nb_quant) 

                }

            }

        rtn_df <- cbind(rtn_df, "X"=vec_cur)

        colnames(rtn_df)[length(colnames(rtn_df))] <- paste("quantile-", as.character(nb_quant), sep="")

        }

        if (st == "mean"){

            for (vr in 1:length(inpt_v)){

                for (idx in 1:length(var_add)){

                    cur_col <- df[, which(col_ns == var_add[idx])]

                    vec_cur[pre_length_var_add * (vr - 1) + mod_idx[idx] + vr] <- mean(cur_col[df[,1] == inpt_v[vr]]) 

                }

            }

        rtn_df <- cbind(rtn_df, "mean"=vec_cur)

        }

    }
    
  }else{ df <- data.frame(inpt_v) }

  return(rtn_df)

}

inter_min <- function(inpt_l, min_=1000, sensi=3, sensi2=3, how_to_op=c("divide"),
                      how_to_val=c(3)){

        diff_v2 <- c()

        diff_v <- c()

        for (lst in 1:len(inpt_l)){

            pre_v <- unlist(inpt_l[lst])

            for (idx in 1:(len(pre_v)-1)){

                diff_v <- c(diff_v, round((pre_v[idx+1] - pre_v[idx]), sensi))

            }

            for (el in diff_v){ diff_v2 <- c(diff_v2, el) }

            if (min(diff_v) < min_){ 

                    min_ <- min(diff_v)

                    diff_v <- c()

            }

        }

        verify <- function(diff_v2, min_){

            for (delta in diff_v2){

                pre_val <- as.character(delta / min_ %% 1)

                pre_val_str <- unlist(strsplit(pre_val, split=""))[0:sensi]

                if (pre_val_str[length(pre_val_str)] != "9"){

                    all_eq <- 0

                }else{

                        all_eq <- 1

                        for (i in 1:(length(pre_val_str)-1)){

                            if (pre_val_str[i+1] != pre_val_str[i] or pre_val_str[i] != "9"){

                                    all_eq <- 0

                            }

                        }

                }

                if (round(pre_val * (10 ** sensi), 0 != 0 & all_eq != 1)){

                    ht <- how_to_op[1]

                    nb <- how_to_val[1]

                    if (length(how_to_op) > 1){

                        how_to_op <- how_to_op[2:length(how_to_op)]

                    }

                    if (length(how_to_val) > 1){

                        how_to_val <- how_to_val[2:length(how_to_op)]

                    }
                
                    if (ht == "divide"){

                        min_ <- round((min_ / nb), sensi)

                    }else if (ht == "add"){

                        min_ <- min_ + nb

                    }else if (ht == "multiply"){

                        min_ <- min * nb

                    }else{

                        min_ <- min_ - nb

                    }

                    return(verify(diff_v2=diff_v2, min_=min_)) 

                }

            }

            sd

        }

}



